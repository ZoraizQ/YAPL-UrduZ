Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CALL
    COMMENT
    DO
    EACH
    ELSE
    FUNCTION
    IN
    LBRACK
    RBRACK
    SEP
    WHILE

Grammar

Rule 0     S' -> uz
Rule 1     uz -> stmt uz
Rule 2     uz -> stmt SEMICOL
Rule 3     uz -> error SEMICOL
Rule 4     uz -> <empty>
Rule 5     stmt -> exp
Rule 6     stmt -> makevar
Rule 7     stmt -> assignment
Rule 8     stmt -> if
Rule 9     stmt -> for
Rule 10    stmt -> print
Rule 11    stmt -> incdec
Rule 12    stmt -> return
Rule 13    stmt -> error
Rule 14    stmtblock -> LBRACE stmtS RBRACE
Rule 15    stmtS -> stmt SEMICOL stmtS
Rule 16    stmtS -> <empty>
Rule 17    exp -> NAME LPAREN optargs RPAREN
Rule 18    optargs -> args
Rule 19    optargs -> <empty>
Rule 20    args -> exp COMMA args
Rule 21    args -> exp
Rule 22    exp -> exp PLUS exp
Rule 23    exp -> exp MINUS exp
Rule 24    exp -> exp MULTIPLY exp
Rule 25    exp -> exp DIVIDE exp
Rule 26    exp -> exp POWER exp
Rule 27    exp -> exp MODULUS exp
Rule 28    exp -> exp AND exp
Rule 29    exp -> exp OR exp
Rule 30    exp -> exp GT exp
Rule 31    exp -> exp LT exp
Rule 32    exp -> exp GTE exp
Rule 33    exp -> exp LTE exp
Rule 34    exp -> exp EE exp
Rule 35    exp -> exp NE exp
Rule 36    exp -> NAME
Rule 37    exp -> MINUS INT
Rule 38    exp -> MINUS FLOAT
Rule 39    exp -> INT
Rule 40    exp -> FLOAT
Rule 41    exp -> DEC exp
Rule 42    exp -> INC exp
Rule 43    incdec -> exp DEC
Rule 44    incdec -> exp INC
Rule 45    exp -> NOT exp
Rule 46    exp -> TRUE
Rule 47    exp -> FALSE
Rule 48    exp -> STRING
Rule 49    exp -> LPAREN exp RPAREN
Rule 50    makevar -> MAKE NAME
Rule 51    makevar -> MAKE assignment
Rule 52    assignment -> NAME EQUAL exp
Rule 53    if -> IF exp THEN stmtblock
Rule 54    elif -> ELIF exp THEN stmtblock elif
Rule 55    elif -> <empty>
Rule 56    for -> FOR assignment TO INT UNTIL
Rule 57    for -> FOR makevar TO INT UNTIL
Rule 58    print -> PRINT LPAREN exp RPAREN
Rule 59    return -> RETURN exp

Terminals, with rules where they appear

AND                  : 28
CALL                 : 
COMMA                : 20
COMMENT              : 
DEC                  : 41 43
DIVIDE               : 25
DO                   : 
EACH                 : 
EE                   : 34
ELIF                 : 54
ELSE                 : 
EQUAL                : 52
FALSE                : 47
FLOAT                : 38 40
FOR                  : 56 57
FUNCTION             : 
GT                   : 30
GTE                  : 32
IF                   : 53
IN                   : 
INC                  : 42 44
INT                  : 37 39 56 57
LBRACE               : 14
LBRACK               : 
LPAREN               : 17 49 58
LT                   : 31
LTE                  : 33
MAKE                 : 50 51
MINUS                : 23 37 38
MODULUS              : 27
MULTIPLY             : 24
NAME                 : 17 36 50 52
NE                   : 35
NOT                  : 45
OR                   : 29
PLUS                 : 22
POWER                : 26
PRINT                : 58
RBRACE               : 14
RBRACK               : 
RETURN               : 59
RPAREN               : 17 49 58
SEMICOL              : 2 3 15
SEP                  : 
STRING               : 48
THEN                 : 53 54
TO                   : 56 57
TRUE                 : 46
UNTIL                : 56 57
WHILE                : 
error                : 3 13

Nonterminals, with rules where they appear

args                 : 18 20
assignment           : 7 51 56
elif                 : 54
exp                  : 5 20 21 22 22 23 23 24 24 25 25 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 41 42 43 44 45 49 52 53 54 58 59
for                  : 9
if                   : 8
incdec               : 11
makevar              : 6 57
optargs              : 17
print                : 10
return               : 12
stmt                 : 1 2 15
stmtS                : 14 15
stmtblock            : 53 54
uz                   : 1 0

Parsing method: LALR

state 0

    (0) S' -> . uz
    (1) uz -> . stmt uz
    (2) uz -> . stmt SEMICOL
    (3) uz -> . error SEMICOL
    (4) uz -> .
    (5) stmt -> . exp
    (6) stmt -> . makevar
    (7) stmt -> . assignment
    (8) stmt -> . if
    (9) stmt -> . for
    (10) stmt -> . print
    (11) stmt -> . incdec
    (12) stmt -> . return
    (13) stmt -> . error
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN
    (50) makevar -> . MAKE NAME
    (51) makevar -> . MAKE assignment
    (52) assignment -> . NAME EQUAL exp
    (53) if -> . IF exp THEN stmtblock
    (56) for -> . FOR assignment TO INT UNTIL
    (57) for -> . FOR makevar TO INT UNTIL
    (58) print -> . PRINT LPAREN exp RPAREN
    (43) incdec -> . exp DEC
    (44) incdec -> . exp INC
    (59) return -> . RETURN exp

    error           shift and go to state 3
    $end            reduce using rule 4 (uz -> .)
    NAME            shift and go to state 12
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13
    MAKE            shift and go to state 23
    IF              shift and go to state 24
    FOR             shift and go to state 25
    PRINT           shift and go to state 26
    RETURN          shift and go to state 27

    uz                             shift and go to state 1
    stmt                           shift and go to state 2
    exp                            shift and go to state 4
    makevar                        shift and go to state 5
    assignment                     shift and go to state 6
    if                             shift and go to state 7
    for                            shift and go to state 8
    print                          shift and go to state 9
    incdec                         shift and go to state 10
    return                         shift and go to state 11

state 1

    (0) S' -> uz .



state 2

    (1) uz -> stmt . uz
    (2) uz -> stmt . SEMICOL
    (1) uz -> . stmt uz
    (2) uz -> . stmt SEMICOL
    (3) uz -> . error SEMICOL
    (4) uz -> .
    (5) stmt -> . exp
    (6) stmt -> . makevar
    (7) stmt -> . assignment
    (8) stmt -> . if
    (9) stmt -> . for
    (10) stmt -> . print
    (11) stmt -> . incdec
    (12) stmt -> . return
    (13) stmt -> . error
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN
    (50) makevar -> . MAKE NAME
    (51) makevar -> . MAKE assignment
    (52) assignment -> . NAME EQUAL exp
    (53) if -> . IF exp THEN stmtblock
    (56) for -> . FOR assignment TO INT UNTIL
    (57) for -> . FOR makevar TO INT UNTIL
    (58) print -> . PRINT LPAREN exp RPAREN
    (43) incdec -> . exp DEC
    (44) incdec -> . exp INC
    (59) return -> . RETURN exp

    SEMICOL         shift and go to state 29
    error           shift and go to state 3
    $end            reduce using rule 4 (uz -> .)
    NAME            shift and go to state 12
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13
    MAKE            shift and go to state 23
    IF              shift and go to state 24
    FOR             shift and go to state 25
    PRINT           shift and go to state 26
    RETURN          shift and go to state 27

    stmt                           shift and go to state 2
    uz                             shift and go to state 28
    exp                            shift and go to state 4
    makevar                        shift and go to state 5
    assignment                     shift and go to state 6
    if                             shift and go to state 7
    for                            shift and go to state 8
    print                          shift and go to state 9
    incdec                         shift and go to state 10
    return                         shift and go to state 11

state 3

    (3) uz -> error . SEMICOL
    (13) stmt -> error .

  ! shift/reduce conflict for SEMICOL resolved as shift
    SEMICOL         shift and go to state 30
    error           reduce using rule 13 (stmt -> error .)
    NAME            reduce using rule 13 (stmt -> error .)
    MINUS           reduce using rule 13 (stmt -> error .)
    INT             reduce using rule 13 (stmt -> error .)
    FLOAT           reduce using rule 13 (stmt -> error .)
    DEC             reduce using rule 13 (stmt -> error .)
    INC             reduce using rule 13 (stmt -> error .)
    NOT             reduce using rule 13 (stmt -> error .)
    TRUE            reduce using rule 13 (stmt -> error .)
    FALSE           reduce using rule 13 (stmt -> error .)
    STRING          reduce using rule 13 (stmt -> error .)
    LPAREN          reduce using rule 13 (stmt -> error .)
    MAKE            reduce using rule 13 (stmt -> error .)
    IF              reduce using rule 13 (stmt -> error .)
    FOR             reduce using rule 13 (stmt -> error .)
    PRINT           reduce using rule 13 (stmt -> error .)
    RETURN          reduce using rule 13 (stmt -> error .)
    $end            reduce using rule 13 (stmt -> error .)

  ! SEMICOL         [ reduce using rule 13 (stmt -> error .) ]


state 4

    (5) stmt -> exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp
    (43) incdec -> exp . DEC
    (44) incdec -> exp . INC

  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INC resolved as shift
    SEMICOL         reduce using rule 5 (stmt -> exp .)
    error           reduce using rule 5 (stmt -> exp .)
    NAME            reduce using rule 5 (stmt -> exp .)
    INT             reduce using rule 5 (stmt -> exp .)
    FLOAT           reduce using rule 5 (stmt -> exp .)
    NOT             reduce using rule 5 (stmt -> exp .)
    TRUE            reduce using rule 5 (stmt -> exp .)
    FALSE           reduce using rule 5 (stmt -> exp .)
    STRING          reduce using rule 5 (stmt -> exp .)
    LPAREN          reduce using rule 5 (stmt -> exp .)
    MAKE            reduce using rule 5 (stmt -> exp .)
    IF              reduce using rule 5 (stmt -> exp .)
    FOR             reduce using rule 5 (stmt -> exp .)
    PRINT           reduce using rule 5 (stmt -> exp .)
    RETURN          reduce using rule 5 (stmt -> exp .)
    $end            reduce using rule 5 (stmt -> exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    POWER           shift and go to state 35
    MODULUS         shift and go to state 36
    AND             shift and go to state 37
    OR              shift and go to state 38
    GT              shift and go to state 39
    LT              shift and go to state 40
    GTE             shift and go to state 41
    LTE             shift and go to state 42
    EE              shift and go to state 43
    NE              shift and go to state 44
    DEC             shift and go to state 45
    INC             shift and go to state 46

  ! MINUS           [ reduce using rule 5 (stmt -> exp .) ]
  ! DEC             [ reduce using rule 5 (stmt -> exp .) ]
  ! INC             [ reduce using rule 5 (stmt -> exp .) ]


state 5

    (6) stmt -> makevar .

    SEMICOL         reduce using rule 6 (stmt -> makevar .)
    error           reduce using rule 6 (stmt -> makevar .)
    NAME            reduce using rule 6 (stmt -> makevar .)
    MINUS           reduce using rule 6 (stmt -> makevar .)
    INT             reduce using rule 6 (stmt -> makevar .)
    FLOAT           reduce using rule 6 (stmt -> makevar .)
    DEC             reduce using rule 6 (stmt -> makevar .)
    INC             reduce using rule 6 (stmt -> makevar .)
    NOT             reduce using rule 6 (stmt -> makevar .)
    TRUE            reduce using rule 6 (stmt -> makevar .)
    FALSE           reduce using rule 6 (stmt -> makevar .)
    STRING          reduce using rule 6 (stmt -> makevar .)
    LPAREN          reduce using rule 6 (stmt -> makevar .)
    MAKE            reduce using rule 6 (stmt -> makevar .)
    IF              reduce using rule 6 (stmt -> makevar .)
    FOR             reduce using rule 6 (stmt -> makevar .)
    PRINT           reduce using rule 6 (stmt -> makevar .)
    RETURN          reduce using rule 6 (stmt -> makevar .)
    $end            reduce using rule 6 (stmt -> makevar .)


state 6

    (7) stmt -> assignment .

    SEMICOL         reduce using rule 7 (stmt -> assignment .)
    error           reduce using rule 7 (stmt -> assignment .)
    NAME            reduce using rule 7 (stmt -> assignment .)
    MINUS           reduce using rule 7 (stmt -> assignment .)
    INT             reduce using rule 7 (stmt -> assignment .)
    FLOAT           reduce using rule 7 (stmt -> assignment .)
    DEC             reduce using rule 7 (stmt -> assignment .)
    INC             reduce using rule 7 (stmt -> assignment .)
    NOT             reduce using rule 7 (stmt -> assignment .)
    TRUE            reduce using rule 7 (stmt -> assignment .)
    FALSE           reduce using rule 7 (stmt -> assignment .)
    STRING          reduce using rule 7 (stmt -> assignment .)
    LPAREN          reduce using rule 7 (stmt -> assignment .)
    MAKE            reduce using rule 7 (stmt -> assignment .)
    IF              reduce using rule 7 (stmt -> assignment .)
    FOR             reduce using rule 7 (stmt -> assignment .)
    PRINT           reduce using rule 7 (stmt -> assignment .)
    RETURN          reduce using rule 7 (stmt -> assignment .)
    $end            reduce using rule 7 (stmt -> assignment .)


state 7

    (8) stmt -> if .

    SEMICOL         reduce using rule 8 (stmt -> if .)
    error           reduce using rule 8 (stmt -> if .)
    NAME            reduce using rule 8 (stmt -> if .)
    MINUS           reduce using rule 8 (stmt -> if .)
    INT             reduce using rule 8 (stmt -> if .)
    FLOAT           reduce using rule 8 (stmt -> if .)
    DEC             reduce using rule 8 (stmt -> if .)
    INC             reduce using rule 8 (stmt -> if .)
    NOT             reduce using rule 8 (stmt -> if .)
    TRUE            reduce using rule 8 (stmt -> if .)
    FALSE           reduce using rule 8 (stmt -> if .)
    STRING          reduce using rule 8 (stmt -> if .)
    LPAREN          reduce using rule 8 (stmt -> if .)
    MAKE            reduce using rule 8 (stmt -> if .)
    IF              reduce using rule 8 (stmt -> if .)
    FOR             reduce using rule 8 (stmt -> if .)
    PRINT           reduce using rule 8 (stmt -> if .)
    RETURN          reduce using rule 8 (stmt -> if .)
    $end            reduce using rule 8 (stmt -> if .)


state 8

    (9) stmt -> for .

    SEMICOL         reduce using rule 9 (stmt -> for .)
    error           reduce using rule 9 (stmt -> for .)
    NAME            reduce using rule 9 (stmt -> for .)
    MINUS           reduce using rule 9 (stmt -> for .)
    INT             reduce using rule 9 (stmt -> for .)
    FLOAT           reduce using rule 9 (stmt -> for .)
    DEC             reduce using rule 9 (stmt -> for .)
    INC             reduce using rule 9 (stmt -> for .)
    NOT             reduce using rule 9 (stmt -> for .)
    TRUE            reduce using rule 9 (stmt -> for .)
    FALSE           reduce using rule 9 (stmt -> for .)
    STRING          reduce using rule 9 (stmt -> for .)
    LPAREN          reduce using rule 9 (stmt -> for .)
    MAKE            reduce using rule 9 (stmt -> for .)
    IF              reduce using rule 9 (stmt -> for .)
    FOR             reduce using rule 9 (stmt -> for .)
    PRINT           reduce using rule 9 (stmt -> for .)
    RETURN          reduce using rule 9 (stmt -> for .)
    $end            reduce using rule 9 (stmt -> for .)


state 9

    (10) stmt -> print .

    SEMICOL         reduce using rule 10 (stmt -> print .)
    error           reduce using rule 10 (stmt -> print .)
    NAME            reduce using rule 10 (stmt -> print .)
    MINUS           reduce using rule 10 (stmt -> print .)
    INT             reduce using rule 10 (stmt -> print .)
    FLOAT           reduce using rule 10 (stmt -> print .)
    DEC             reduce using rule 10 (stmt -> print .)
    INC             reduce using rule 10 (stmt -> print .)
    NOT             reduce using rule 10 (stmt -> print .)
    TRUE            reduce using rule 10 (stmt -> print .)
    FALSE           reduce using rule 10 (stmt -> print .)
    STRING          reduce using rule 10 (stmt -> print .)
    LPAREN          reduce using rule 10 (stmt -> print .)
    MAKE            reduce using rule 10 (stmt -> print .)
    IF              reduce using rule 10 (stmt -> print .)
    FOR             reduce using rule 10 (stmt -> print .)
    PRINT           reduce using rule 10 (stmt -> print .)
    RETURN          reduce using rule 10 (stmt -> print .)
    $end            reduce using rule 10 (stmt -> print .)


state 10

    (11) stmt -> incdec .

    SEMICOL         reduce using rule 11 (stmt -> incdec .)
    error           reduce using rule 11 (stmt -> incdec .)
    NAME            reduce using rule 11 (stmt -> incdec .)
    MINUS           reduce using rule 11 (stmt -> incdec .)
    INT             reduce using rule 11 (stmt -> incdec .)
    FLOAT           reduce using rule 11 (stmt -> incdec .)
    DEC             reduce using rule 11 (stmt -> incdec .)
    INC             reduce using rule 11 (stmt -> incdec .)
    NOT             reduce using rule 11 (stmt -> incdec .)
    TRUE            reduce using rule 11 (stmt -> incdec .)
    FALSE           reduce using rule 11 (stmt -> incdec .)
    STRING          reduce using rule 11 (stmt -> incdec .)
    LPAREN          reduce using rule 11 (stmt -> incdec .)
    MAKE            reduce using rule 11 (stmt -> incdec .)
    IF              reduce using rule 11 (stmt -> incdec .)
    FOR             reduce using rule 11 (stmt -> incdec .)
    PRINT           reduce using rule 11 (stmt -> incdec .)
    RETURN          reduce using rule 11 (stmt -> incdec .)
    $end            reduce using rule 11 (stmt -> incdec .)


state 11

    (12) stmt -> return .

    SEMICOL         reduce using rule 12 (stmt -> return .)
    error           reduce using rule 12 (stmt -> return .)
    NAME            reduce using rule 12 (stmt -> return .)
    MINUS           reduce using rule 12 (stmt -> return .)
    INT             reduce using rule 12 (stmt -> return .)
    FLOAT           reduce using rule 12 (stmt -> return .)
    DEC             reduce using rule 12 (stmt -> return .)
    INC             reduce using rule 12 (stmt -> return .)
    NOT             reduce using rule 12 (stmt -> return .)
    TRUE            reduce using rule 12 (stmt -> return .)
    FALSE           reduce using rule 12 (stmt -> return .)
    STRING          reduce using rule 12 (stmt -> return .)
    LPAREN          reduce using rule 12 (stmt -> return .)
    MAKE            reduce using rule 12 (stmt -> return .)
    IF              reduce using rule 12 (stmt -> return .)
    FOR             reduce using rule 12 (stmt -> return .)
    PRINT           reduce using rule 12 (stmt -> return .)
    RETURN          reduce using rule 12 (stmt -> return .)
    $end            reduce using rule 12 (stmt -> return .)


state 12

    (17) exp -> NAME . LPAREN optargs RPAREN
    (36) exp -> NAME .
    (52) assignment -> NAME . EQUAL exp

  ! shift/reduce conflict for LPAREN resolved as shift
    LPAREN          shift and go to state 47
    PLUS            reduce using rule 36 (exp -> NAME .)
    MINUS           reduce using rule 36 (exp -> NAME .)
    MULTIPLY        reduce using rule 36 (exp -> NAME .)
    DIVIDE          reduce using rule 36 (exp -> NAME .)
    POWER           reduce using rule 36 (exp -> NAME .)
    MODULUS         reduce using rule 36 (exp -> NAME .)
    AND             reduce using rule 36 (exp -> NAME .)
    OR              reduce using rule 36 (exp -> NAME .)
    GT              reduce using rule 36 (exp -> NAME .)
    LT              reduce using rule 36 (exp -> NAME .)
    GTE             reduce using rule 36 (exp -> NAME .)
    LTE             reduce using rule 36 (exp -> NAME .)
    EE              reduce using rule 36 (exp -> NAME .)
    NE              reduce using rule 36 (exp -> NAME .)
    DEC             reduce using rule 36 (exp -> NAME .)
    INC             reduce using rule 36 (exp -> NAME .)
    SEMICOL         reduce using rule 36 (exp -> NAME .)
    error           reduce using rule 36 (exp -> NAME .)
    NAME            reduce using rule 36 (exp -> NAME .)
    INT             reduce using rule 36 (exp -> NAME .)
    FLOAT           reduce using rule 36 (exp -> NAME .)
    NOT             reduce using rule 36 (exp -> NAME .)
    TRUE            reduce using rule 36 (exp -> NAME .)
    FALSE           reduce using rule 36 (exp -> NAME .)
    STRING          reduce using rule 36 (exp -> NAME .)
    MAKE            reduce using rule 36 (exp -> NAME .)
    IF              reduce using rule 36 (exp -> NAME .)
    FOR             reduce using rule 36 (exp -> NAME .)
    PRINT           reduce using rule 36 (exp -> NAME .)
    RETURN          reduce using rule 36 (exp -> NAME .)
    $end            reduce using rule 36 (exp -> NAME .)
    EQUAL           shift and go to state 48

  ! LPAREN          [ reduce using rule 36 (exp -> NAME .) ]


state 13

    (49) exp -> LPAREN . exp RPAREN
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 49

state 14

    (37) exp -> MINUS . INT
    (38) exp -> MINUS . FLOAT

    INT             shift and go to state 51
    FLOAT           shift and go to state 52


state 15

    (39) exp -> INT .

    PLUS            reduce using rule 39 (exp -> INT .)
    MINUS           reduce using rule 39 (exp -> INT .)
    MULTIPLY        reduce using rule 39 (exp -> INT .)
    DIVIDE          reduce using rule 39 (exp -> INT .)
    POWER           reduce using rule 39 (exp -> INT .)
    MODULUS         reduce using rule 39 (exp -> INT .)
    AND             reduce using rule 39 (exp -> INT .)
    OR              reduce using rule 39 (exp -> INT .)
    GT              reduce using rule 39 (exp -> INT .)
    LT              reduce using rule 39 (exp -> INT .)
    GTE             reduce using rule 39 (exp -> INT .)
    LTE             reduce using rule 39 (exp -> INT .)
    EE              reduce using rule 39 (exp -> INT .)
    NE              reduce using rule 39 (exp -> INT .)
    DEC             reduce using rule 39 (exp -> INT .)
    INC             reduce using rule 39 (exp -> INT .)
    SEMICOL         reduce using rule 39 (exp -> INT .)
    error           reduce using rule 39 (exp -> INT .)
    NAME            reduce using rule 39 (exp -> INT .)
    INT             reduce using rule 39 (exp -> INT .)
    FLOAT           reduce using rule 39 (exp -> INT .)
    NOT             reduce using rule 39 (exp -> INT .)
    TRUE            reduce using rule 39 (exp -> INT .)
    FALSE           reduce using rule 39 (exp -> INT .)
    STRING          reduce using rule 39 (exp -> INT .)
    LPAREN          reduce using rule 39 (exp -> INT .)
    MAKE            reduce using rule 39 (exp -> INT .)
    IF              reduce using rule 39 (exp -> INT .)
    FOR             reduce using rule 39 (exp -> INT .)
    PRINT           reduce using rule 39 (exp -> INT .)
    RETURN          reduce using rule 39 (exp -> INT .)
    $end            reduce using rule 39 (exp -> INT .)
    RPAREN          reduce using rule 39 (exp -> INT .)
    THEN            reduce using rule 39 (exp -> INT .)
    COMMA           reduce using rule 39 (exp -> INT .)
    TO              reduce using rule 39 (exp -> INT .)


state 16

    (40) exp -> FLOAT .

    PLUS            reduce using rule 40 (exp -> FLOAT .)
    MINUS           reduce using rule 40 (exp -> FLOAT .)
    MULTIPLY        reduce using rule 40 (exp -> FLOAT .)
    DIVIDE          reduce using rule 40 (exp -> FLOAT .)
    POWER           reduce using rule 40 (exp -> FLOAT .)
    MODULUS         reduce using rule 40 (exp -> FLOAT .)
    AND             reduce using rule 40 (exp -> FLOAT .)
    OR              reduce using rule 40 (exp -> FLOAT .)
    GT              reduce using rule 40 (exp -> FLOAT .)
    LT              reduce using rule 40 (exp -> FLOAT .)
    GTE             reduce using rule 40 (exp -> FLOAT .)
    LTE             reduce using rule 40 (exp -> FLOAT .)
    EE              reduce using rule 40 (exp -> FLOAT .)
    NE              reduce using rule 40 (exp -> FLOAT .)
    DEC             reduce using rule 40 (exp -> FLOAT .)
    INC             reduce using rule 40 (exp -> FLOAT .)
    SEMICOL         reduce using rule 40 (exp -> FLOAT .)
    error           reduce using rule 40 (exp -> FLOAT .)
    NAME            reduce using rule 40 (exp -> FLOAT .)
    INT             reduce using rule 40 (exp -> FLOAT .)
    FLOAT           reduce using rule 40 (exp -> FLOAT .)
    NOT             reduce using rule 40 (exp -> FLOAT .)
    TRUE            reduce using rule 40 (exp -> FLOAT .)
    FALSE           reduce using rule 40 (exp -> FLOAT .)
    STRING          reduce using rule 40 (exp -> FLOAT .)
    LPAREN          reduce using rule 40 (exp -> FLOAT .)
    MAKE            reduce using rule 40 (exp -> FLOAT .)
    IF              reduce using rule 40 (exp -> FLOAT .)
    FOR             reduce using rule 40 (exp -> FLOAT .)
    PRINT           reduce using rule 40 (exp -> FLOAT .)
    RETURN          reduce using rule 40 (exp -> FLOAT .)
    $end            reduce using rule 40 (exp -> FLOAT .)
    RPAREN          reduce using rule 40 (exp -> FLOAT .)
    THEN            reduce using rule 40 (exp -> FLOAT .)
    COMMA           reduce using rule 40 (exp -> FLOAT .)
    TO              reduce using rule 40 (exp -> FLOAT .)


state 17

    (41) exp -> DEC . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 53

state 18

    (42) exp -> INC . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 54

state 19

    (45) exp -> NOT . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 55

state 20

    (46) exp -> TRUE .

    PLUS            reduce using rule 46 (exp -> TRUE .)
    MINUS           reduce using rule 46 (exp -> TRUE .)
    MULTIPLY        reduce using rule 46 (exp -> TRUE .)
    DIVIDE          reduce using rule 46 (exp -> TRUE .)
    POWER           reduce using rule 46 (exp -> TRUE .)
    MODULUS         reduce using rule 46 (exp -> TRUE .)
    AND             reduce using rule 46 (exp -> TRUE .)
    OR              reduce using rule 46 (exp -> TRUE .)
    GT              reduce using rule 46 (exp -> TRUE .)
    LT              reduce using rule 46 (exp -> TRUE .)
    GTE             reduce using rule 46 (exp -> TRUE .)
    LTE             reduce using rule 46 (exp -> TRUE .)
    EE              reduce using rule 46 (exp -> TRUE .)
    NE              reduce using rule 46 (exp -> TRUE .)
    DEC             reduce using rule 46 (exp -> TRUE .)
    INC             reduce using rule 46 (exp -> TRUE .)
    SEMICOL         reduce using rule 46 (exp -> TRUE .)
    error           reduce using rule 46 (exp -> TRUE .)
    NAME            reduce using rule 46 (exp -> TRUE .)
    INT             reduce using rule 46 (exp -> TRUE .)
    FLOAT           reduce using rule 46 (exp -> TRUE .)
    NOT             reduce using rule 46 (exp -> TRUE .)
    TRUE            reduce using rule 46 (exp -> TRUE .)
    FALSE           reduce using rule 46 (exp -> TRUE .)
    STRING          reduce using rule 46 (exp -> TRUE .)
    LPAREN          reduce using rule 46 (exp -> TRUE .)
    MAKE            reduce using rule 46 (exp -> TRUE .)
    IF              reduce using rule 46 (exp -> TRUE .)
    FOR             reduce using rule 46 (exp -> TRUE .)
    PRINT           reduce using rule 46 (exp -> TRUE .)
    RETURN          reduce using rule 46 (exp -> TRUE .)
    $end            reduce using rule 46 (exp -> TRUE .)
    RPAREN          reduce using rule 46 (exp -> TRUE .)
    THEN            reduce using rule 46 (exp -> TRUE .)
    COMMA           reduce using rule 46 (exp -> TRUE .)
    TO              reduce using rule 46 (exp -> TRUE .)


state 21

    (47) exp -> FALSE .

    PLUS            reduce using rule 47 (exp -> FALSE .)
    MINUS           reduce using rule 47 (exp -> FALSE .)
    MULTIPLY        reduce using rule 47 (exp -> FALSE .)
    DIVIDE          reduce using rule 47 (exp -> FALSE .)
    POWER           reduce using rule 47 (exp -> FALSE .)
    MODULUS         reduce using rule 47 (exp -> FALSE .)
    AND             reduce using rule 47 (exp -> FALSE .)
    OR              reduce using rule 47 (exp -> FALSE .)
    GT              reduce using rule 47 (exp -> FALSE .)
    LT              reduce using rule 47 (exp -> FALSE .)
    GTE             reduce using rule 47 (exp -> FALSE .)
    LTE             reduce using rule 47 (exp -> FALSE .)
    EE              reduce using rule 47 (exp -> FALSE .)
    NE              reduce using rule 47 (exp -> FALSE .)
    DEC             reduce using rule 47 (exp -> FALSE .)
    INC             reduce using rule 47 (exp -> FALSE .)
    SEMICOL         reduce using rule 47 (exp -> FALSE .)
    error           reduce using rule 47 (exp -> FALSE .)
    NAME            reduce using rule 47 (exp -> FALSE .)
    INT             reduce using rule 47 (exp -> FALSE .)
    FLOAT           reduce using rule 47 (exp -> FALSE .)
    NOT             reduce using rule 47 (exp -> FALSE .)
    TRUE            reduce using rule 47 (exp -> FALSE .)
    FALSE           reduce using rule 47 (exp -> FALSE .)
    STRING          reduce using rule 47 (exp -> FALSE .)
    LPAREN          reduce using rule 47 (exp -> FALSE .)
    MAKE            reduce using rule 47 (exp -> FALSE .)
    IF              reduce using rule 47 (exp -> FALSE .)
    FOR             reduce using rule 47 (exp -> FALSE .)
    PRINT           reduce using rule 47 (exp -> FALSE .)
    RETURN          reduce using rule 47 (exp -> FALSE .)
    $end            reduce using rule 47 (exp -> FALSE .)
    RPAREN          reduce using rule 47 (exp -> FALSE .)
    THEN            reduce using rule 47 (exp -> FALSE .)
    COMMA           reduce using rule 47 (exp -> FALSE .)
    TO              reduce using rule 47 (exp -> FALSE .)


state 22

    (48) exp -> STRING .

    PLUS            reduce using rule 48 (exp -> STRING .)
    MINUS           reduce using rule 48 (exp -> STRING .)
    MULTIPLY        reduce using rule 48 (exp -> STRING .)
    DIVIDE          reduce using rule 48 (exp -> STRING .)
    POWER           reduce using rule 48 (exp -> STRING .)
    MODULUS         reduce using rule 48 (exp -> STRING .)
    AND             reduce using rule 48 (exp -> STRING .)
    OR              reduce using rule 48 (exp -> STRING .)
    GT              reduce using rule 48 (exp -> STRING .)
    LT              reduce using rule 48 (exp -> STRING .)
    GTE             reduce using rule 48 (exp -> STRING .)
    LTE             reduce using rule 48 (exp -> STRING .)
    EE              reduce using rule 48 (exp -> STRING .)
    NE              reduce using rule 48 (exp -> STRING .)
    DEC             reduce using rule 48 (exp -> STRING .)
    INC             reduce using rule 48 (exp -> STRING .)
    SEMICOL         reduce using rule 48 (exp -> STRING .)
    error           reduce using rule 48 (exp -> STRING .)
    NAME            reduce using rule 48 (exp -> STRING .)
    INT             reduce using rule 48 (exp -> STRING .)
    FLOAT           reduce using rule 48 (exp -> STRING .)
    NOT             reduce using rule 48 (exp -> STRING .)
    TRUE            reduce using rule 48 (exp -> STRING .)
    FALSE           reduce using rule 48 (exp -> STRING .)
    STRING          reduce using rule 48 (exp -> STRING .)
    LPAREN          reduce using rule 48 (exp -> STRING .)
    MAKE            reduce using rule 48 (exp -> STRING .)
    IF              reduce using rule 48 (exp -> STRING .)
    FOR             reduce using rule 48 (exp -> STRING .)
    PRINT           reduce using rule 48 (exp -> STRING .)
    RETURN          reduce using rule 48 (exp -> STRING .)
    $end            reduce using rule 48 (exp -> STRING .)
    RPAREN          reduce using rule 48 (exp -> STRING .)
    THEN            reduce using rule 48 (exp -> STRING .)
    COMMA           reduce using rule 48 (exp -> STRING .)
    TO              reduce using rule 48 (exp -> STRING .)


state 23

    (50) makevar -> MAKE . NAME
    (51) makevar -> MAKE . assignment
    (52) assignment -> . NAME EQUAL exp

    NAME            shift and go to state 56

    assignment                     shift and go to state 57

state 24

    (53) if -> IF . exp THEN stmtblock
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 58

state 25

    (56) for -> FOR . assignment TO INT UNTIL
    (57) for -> FOR . makevar TO INT UNTIL
    (52) assignment -> . NAME EQUAL exp
    (50) makevar -> . MAKE NAME
    (51) makevar -> . MAKE assignment

    NAME            shift and go to state 61
    MAKE            shift and go to state 23

    assignment                     shift and go to state 59
    makevar                        shift and go to state 60

state 26

    (58) print -> PRINT . LPAREN exp RPAREN

    LPAREN          shift and go to state 62


state 27

    (59) return -> RETURN . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 63

state 28

    (1) uz -> stmt uz .

    $end            reduce using rule 1 (uz -> stmt uz .)


state 29

    (2) uz -> stmt SEMICOL .

    $end            reduce using rule 2 (uz -> stmt SEMICOL .)


state 30

    (3) uz -> error SEMICOL .

    $end            reduce using rule 3 (uz -> error SEMICOL .)


state 31

    (22) exp -> exp PLUS . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 64

state 32

    (23) exp -> exp MINUS . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 65

state 33

    (24) exp -> exp MULTIPLY . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 66

state 34

    (25) exp -> exp DIVIDE . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 67

state 35

    (26) exp -> exp POWER . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 68

state 36

    (27) exp -> exp MODULUS . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 69

state 37

    (28) exp -> exp AND . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 70

state 38

    (29) exp -> exp OR . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 71

state 39

    (30) exp -> exp GT . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 72

state 40

    (31) exp -> exp LT . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 73

state 41

    (32) exp -> exp GTE . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 74

state 42

    (33) exp -> exp LTE . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 75

state 43

    (34) exp -> exp EE . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 76

state 44

    (35) exp -> exp NE . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 77

state 45

    (43) incdec -> exp DEC .

    SEMICOL         reduce using rule 43 (incdec -> exp DEC .)
    error           reduce using rule 43 (incdec -> exp DEC .)
    NAME            reduce using rule 43 (incdec -> exp DEC .)
    MINUS           reduce using rule 43 (incdec -> exp DEC .)
    INT             reduce using rule 43 (incdec -> exp DEC .)
    FLOAT           reduce using rule 43 (incdec -> exp DEC .)
    DEC             reduce using rule 43 (incdec -> exp DEC .)
    INC             reduce using rule 43 (incdec -> exp DEC .)
    NOT             reduce using rule 43 (incdec -> exp DEC .)
    TRUE            reduce using rule 43 (incdec -> exp DEC .)
    FALSE           reduce using rule 43 (incdec -> exp DEC .)
    STRING          reduce using rule 43 (incdec -> exp DEC .)
    LPAREN          reduce using rule 43 (incdec -> exp DEC .)
    MAKE            reduce using rule 43 (incdec -> exp DEC .)
    IF              reduce using rule 43 (incdec -> exp DEC .)
    FOR             reduce using rule 43 (incdec -> exp DEC .)
    PRINT           reduce using rule 43 (incdec -> exp DEC .)
    RETURN          reduce using rule 43 (incdec -> exp DEC .)
    $end            reduce using rule 43 (incdec -> exp DEC .)


state 46

    (44) incdec -> exp INC .

    SEMICOL         reduce using rule 44 (incdec -> exp INC .)
    error           reduce using rule 44 (incdec -> exp INC .)
    NAME            reduce using rule 44 (incdec -> exp INC .)
    MINUS           reduce using rule 44 (incdec -> exp INC .)
    INT             reduce using rule 44 (incdec -> exp INC .)
    FLOAT           reduce using rule 44 (incdec -> exp INC .)
    DEC             reduce using rule 44 (incdec -> exp INC .)
    INC             reduce using rule 44 (incdec -> exp INC .)
    NOT             reduce using rule 44 (incdec -> exp INC .)
    TRUE            reduce using rule 44 (incdec -> exp INC .)
    FALSE           reduce using rule 44 (incdec -> exp INC .)
    STRING          reduce using rule 44 (incdec -> exp INC .)
    LPAREN          reduce using rule 44 (incdec -> exp INC .)
    MAKE            reduce using rule 44 (incdec -> exp INC .)
    IF              reduce using rule 44 (incdec -> exp INC .)
    FOR             reduce using rule 44 (incdec -> exp INC .)
    PRINT           reduce using rule 44 (incdec -> exp INC .)
    RETURN          reduce using rule 44 (incdec -> exp INC .)
    $end            reduce using rule 44 (incdec -> exp INC .)


state 47

    (17) exp -> NAME LPAREN . optargs RPAREN
    (18) optargs -> . args
    (19) optargs -> .
    (20) args -> . exp COMMA args
    (21) args -> . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    RPAREN          reduce using rule 19 (optargs -> .)
    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    optargs                        shift and go to state 78
    args                           shift and go to state 79
    exp                            shift and go to state 80

state 48

    (52) assignment -> NAME EQUAL . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 81

state 49

    (49) exp -> LPAREN exp . RPAREN
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

    RPAREN          shift and go to state 82
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    POWER           shift and go to state 35
    MODULUS         shift and go to state 36
    AND             shift and go to state 37
    OR              shift and go to state 38
    GT              shift and go to state 39
    LT              shift and go to state 40
    GTE             shift and go to state 41
    LTE             shift and go to state 42
    EE              shift and go to state 43
    NE              shift and go to state 44


state 50

    (17) exp -> NAME . LPAREN optargs RPAREN
    (36) exp -> NAME .

  ! shift/reduce conflict for LPAREN resolved as shift
    LPAREN          shift and go to state 47
    RPAREN          reduce using rule 36 (exp -> NAME .)
    PLUS            reduce using rule 36 (exp -> NAME .)
    MINUS           reduce using rule 36 (exp -> NAME .)
    MULTIPLY        reduce using rule 36 (exp -> NAME .)
    DIVIDE          reduce using rule 36 (exp -> NAME .)
    POWER           reduce using rule 36 (exp -> NAME .)
    MODULUS         reduce using rule 36 (exp -> NAME .)
    AND             reduce using rule 36 (exp -> NAME .)
    OR              reduce using rule 36 (exp -> NAME .)
    GT              reduce using rule 36 (exp -> NAME .)
    LT              reduce using rule 36 (exp -> NAME .)
    GTE             reduce using rule 36 (exp -> NAME .)
    LTE             reduce using rule 36 (exp -> NAME .)
    EE              reduce using rule 36 (exp -> NAME .)
    NE              reduce using rule 36 (exp -> NAME .)
    DEC             reduce using rule 36 (exp -> NAME .)
    INC             reduce using rule 36 (exp -> NAME .)
    SEMICOL         reduce using rule 36 (exp -> NAME .)
    error           reduce using rule 36 (exp -> NAME .)
    NAME            reduce using rule 36 (exp -> NAME .)
    INT             reduce using rule 36 (exp -> NAME .)
    FLOAT           reduce using rule 36 (exp -> NAME .)
    NOT             reduce using rule 36 (exp -> NAME .)
    TRUE            reduce using rule 36 (exp -> NAME .)
    FALSE           reduce using rule 36 (exp -> NAME .)
    STRING          reduce using rule 36 (exp -> NAME .)
    MAKE            reduce using rule 36 (exp -> NAME .)
    IF              reduce using rule 36 (exp -> NAME .)
    FOR             reduce using rule 36 (exp -> NAME .)
    PRINT           reduce using rule 36 (exp -> NAME .)
    RETURN          reduce using rule 36 (exp -> NAME .)
    $end            reduce using rule 36 (exp -> NAME .)
    THEN            reduce using rule 36 (exp -> NAME .)
    COMMA           reduce using rule 36 (exp -> NAME .)
    TO              reduce using rule 36 (exp -> NAME .)

  ! LPAREN          [ reduce using rule 36 (exp -> NAME .) ]


state 51

    (37) exp -> MINUS INT .

    PLUS            reduce using rule 37 (exp -> MINUS INT .)
    MINUS           reduce using rule 37 (exp -> MINUS INT .)
    MULTIPLY        reduce using rule 37 (exp -> MINUS INT .)
    DIVIDE          reduce using rule 37 (exp -> MINUS INT .)
    POWER           reduce using rule 37 (exp -> MINUS INT .)
    MODULUS         reduce using rule 37 (exp -> MINUS INT .)
    AND             reduce using rule 37 (exp -> MINUS INT .)
    OR              reduce using rule 37 (exp -> MINUS INT .)
    GT              reduce using rule 37 (exp -> MINUS INT .)
    LT              reduce using rule 37 (exp -> MINUS INT .)
    GTE             reduce using rule 37 (exp -> MINUS INT .)
    LTE             reduce using rule 37 (exp -> MINUS INT .)
    EE              reduce using rule 37 (exp -> MINUS INT .)
    NE              reduce using rule 37 (exp -> MINUS INT .)
    DEC             reduce using rule 37 (exp -> MINUS INT .)
    INC             reduce using rule 37 (exp -> MINUS INT .)
    SEMICOL         reduce using rule 37 (exp -> MINUS INT .)
    error           reduce using rule 37 (exp -> MINUS INT .)
    NAME            reduce using rule 37 (exp -> MINUS INT .)
    INT             reduce using rule 37 (exp -> MINUS INT .)
    FLOAT           reduce using rule 37 (exp -> MINUS INT .)
    NOT             reduce using rule 37 (exp -> MINUS INT .)
    TRUE            reduce using rule 37 (exp -> MINUS INT .)
    FALSE           reduce using rule 37 (exp -> MINUS INT .)
    STRING          reduce using rule 37 (exp -> MINUS INT .)
    LPAREN          reduce using rule 37 (exp -> MINUS INT .)
    MAKE            reduce using rule 37 (exp -> MINUS INT .)
    IF              reduce using rule 37 (exp -> MINUS INT .)
    FOR             reduce using rule 37 (exp -> MINUS INT .)
    PRINT           reduce using rule 37 (exp -> MINUS INT .)
    RETURN          reduce using rule 37 (exp -> MINUS INT .)
    $end            reduce using rule 37 (exp -> MINUS INT .)
    RPAREN          reduce using rule 37 (exp -> MINUS INT .)
    THEN            reduce using rule 37 (exp -> MINUS INT .)
    COMMA           reduce using rule 37 (exp -> MINUS INT .)
    TO              reduce using rule 37 (exp -> MINUS INT .)


state 52

    (38) exp -> MINUS FLOAT .

    PLUS            reduce using rule 38 (exp -> MINUS FLOAT .)
    MINUS           reduce using rule 38 (exp -> MINUS FLOAT .)
    MULTIPLY        reduce using rule 38 (exp -> MINUS FLOAT .)
    DIVIDE          reduce using rule 38 (exp -> MINUS FLOAT .)
    POWER           reduce using rule 38 (exp -> MINUS FLOAT .)
    MODULUS         reduce using rule 38 (exp -> MINUS FLOAT .)
    AND             reduce using rule 38 (exp -> MINUS FLOAT .)
    OR              reduce using rule 38 (exp -> MINUS FLOAT .)
    GT              reduce using rule 38 (exp -> MINUS FLOAT .)
    LT              reduce using rule 38 (exp -> MINUS FLOAT .)
    GTE             reduce using rule 38 (exp -> MINUS FLOAT .)
    LTE             reduce using rule 38 (exp -> MINUS FLOAT .)
    EE              reduce using rule 38 (exp -> MINUS FLOAT .)
    NE              reduce using rule 38 (exp -> MINUS FLOAT .)
    DEC             reduce using rule 38 (exp -> MINUS FLOAT .)
    INC             reduce using rule 38 (exp -> MINUS FLOAT .)
    SEMICOL         reduce using rule 38 (exp -> MINUS FLOAT .)
    error           reduce using rule 38 (exp -> MINUS FLOAT .)
    NAME            reduce using rule 38 (exp -> MINUS FLOAT .)
    INT             reduce using rule 38 (exp -> MINUS FLOAT .)
    FLOAT           reduce using rule 38 (exp -> MINUS FLOAT .)
    NOT             reduce using rule 38 (exp -> MINUS FLOAT .)
    TRUE            reduce using rule 38 (exp -> MINUS FLOAT .)
    FALSE           reduce using rule 38 (exp -> MINUS FLOAT .)
    STRING          reduce using rule 38 (exp -> MINUS FLOAT .)
    LPAREN          reduce using rule 38 (exp -> MINUS FLOAT .)
    MAKE            reduce using rule 38 (exp -> MINUS FLOAT .)
    IF              reduce using rule 38 (exp -> MINUS FLOAT .)
    FOR             reduce using rule 38 (exp -> MINUS FLOAT .)
    PRINT           reduce using rule 38 (exp -> MINUS FLOAT .)
    RETURN          reduce using rule 38 (exp -> MINUS FLOAT .)
    $end            reduce using rule 38 (exp -> MINUS FLOAT .)
    RPAREN          reduce using rule 38 (exp -> MINUS FLOAT .)
    THEN            reduce using rule 38 (exp -> MINUS FLOAT .)
    COMMA           reduce using rule 38 (exp -> MINUS FLOAT .)
    TO              reduce using rule 38 (exp -> MINUS FLOAT .)


state 53

    (41) exp -> DEC exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

    POWER           reduce using rule 41 (exp -> DEC exp .)
    MODULUS         reduce using rule 41 (exp -> DEC exp .)
    DEC             reduce using rule 41 (exp -> DEC exp .)
    INC             reduce using rule 41 (exp -> DEC exp .)
    SEMICOL         reduce using rule 41 (exp -> DEC exp .)
    error           reduce using rule 41 (exp -> DEC exp .)
    NAME            reduce using rule 41 (exp -> DEC exp .)
    INT             reduce using rule 41 (exp -> DEC exp .)
    FLOAT           reduce using rule 41 (exp -> DEC exp .)
    NOT             reduce using rule 41 (exp -> DEC exp .)
    TRUE            reduce using rule 41 (exp -> DEC exp .)
    FALSE           reduce using rule 41 (exp -> DEC exp .)
    STRING          reduce using rule 41 (exp -> DEC exp .)
    LPAREN          reduce using rule 41 (exp -> DEC exp .)
    MAKE            reduce using rule 41 (exp -> DEC exp .)
    IF              reduce using rule 41 (exp -> DEC exp .)
    FOR             reduce using rule 41 (exp -> DEC exp .)
    PRINT           reduce using rule 41 (exp -> DEC exp .)
    RETURN          reduce using rule 41 (exp -> DEC exp .)
    $end            reduce using rule 41 (exp -> DEC exp .)
    RPAREN          reduce using rule 41 (exp -> DEC exp .)
    THEN            reduce using rule 41 (exp -> DEC exp .)
    COMMA           reduce using rule 41 (exp -> DEC exp .)
    TO              reduce using rule 41 (exp -> DEC exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    AND             shift and go to state 37
    OR              shift and go to state 38
    GT              shift and go to state 39
    LT              shift and go to state 40
    GTE             shift and go to state 41
    LTE             shift and go to state 42
    EE              shift and go to state 43
    NE              shift and go to state 44

  ! PLUS            [ reduce using rule 41 (exp -> DEC exp .) ]
  ! MINUS           [ reduce using rule 41 (exp -> DEC exp .) ]
  ! MULTIPLY        [ reduce using rule 41 (exp -> DEC exp .) ]
  ! DIVIDE          [ reduce using rule 41 (exp -> DEC exp .) ]
  ! AND             [ reduce using rule 41 (exp -> DEC exp .) ]
  ! OR              [ reduce using rule 41 (exp -> DEC exp .) ]
  ! GT              [ reduce using rule 41 (exp -> DEC exp .) ]
  ! LT              [ reduce using rule 41 (exp -> DEC exp .) ]
  ! GTE             [ reduce using rule 41 (exp -> DEC exp .) ]
  ! LTE             [ reduce using rule 41 (exp -> DEC exp .) ]
  ! EE              [ reduce using rule 41 (exp -> DEC exp .) ]
  ! NE              [ reduce using rule 41 (exp -> DEC exp .) ]
  ! POWER           [ shift and go to state 35 ]
  ! MODULUS         [ shift and go to state 36 ]


state 54

    (42) exp -> INC exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

    POWER           reduce using rule 42 (exp -> INC exp .)
    MODULUS         reduce using rule 42 (exp -> INC exp .)
    DEC             reduce using rule 42 (exp -> INC exp .)
    INC             reduce using rule 42 (exp -> INC exp .)
    SEMICOL         reduce using rule 42 (exp -> INC exp .)
    error           reduce using rule 42 (exp -> INC exp .)
    NAME            reduce using rule 42 (exp -> INC exp .)
    INT             reduce using rule 42 (exp -> INC exp .)
    FLOAT           reduce using rule 42 (exp -> INC exp .)
    NOT             reduce using rule 42 (exp -> INC exp .)
    TRUE            reduce using rule 42 (exp -> INC exp .)
    FALSE           reduce using rule 42 (exp -> INC exp .)
    STRING          reduce using rule 42 (exp -> INC exp .)
    LPAREN          reduce using rule 42 (exp -> INC exp .)
    MAKE            reduce using rule 42 (exp -> INC exp .)
    IF              reduce using rule 42 (exp -> INC exp .)
    FOR             reduce using rule 42 (exp -> INC exp .)
    PRINT           reduce using rule 42 (exp -> INC exp .)
    RETURN          reduce using rule 42 (exp -> INC exp .)
    $end            reduce using rule 42 (exp -> INC exp .)
    RPAREN          reduce using rule 42 (exp -> INC exp .)
    THEN            reduce using rule 42 (exp -> INC exp .)
    COMMA           reduce using rule 42 (exp -> INC exp .)
    TO              reduce using rule 42 (exp -> INC exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    AND             shift and go to state 37
    OR              shift and go to state 38
    GT              shift and go to state 39
    LT              shift and go to state 40
    GTE             shift and go to state 41
    LTE             shift and go to state 42
    EE              shift and go to state 43
    NE              shift and go to state 44

  ! PLUS            [ reduce using rule 42 (exp -> INC exp .) ]
  ! MINUS           [ reduce using rule 42 (exp -> INC exp .) ]
  ! MULTIPLY        [ reduce using rule 42 (exp -> INC exp .) ]
  ! DIVIDE          [ reduce using rule 42 (exp -> INC exp .) ]
  ! AND             [ reduce using rule 42 (exp -> INC exp .) ]
  ! OR              [ reduce using rule 42 (exp -> INC exp .) ]
  ! GT              [ reduce using rule 42 (exp -> INC exp .) ]
  ! LT              [ reduce using rule 42 (exp -> INC exp .) ]
  ! GTE             [ reduce using rule 42 (exp -> INC exp .) ]
  ! LTE             [ reduce using rule 42 (exp -> INC exp .) ]
  ! EE              [ reduce using rule 42 (exp -> INC exp .) ]
  ! NE              [ reduce using rule 42 (exp -> INC exp .) ]
  ! POWER           [ shift and go to state 35 ]
  ! MODULUS         [ shift and go to state 36 ]


state 55

    (45) exp -> NOT exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

    PLUS            reduce using rule 45 (exp -> NOT exp .)
    MINUS           reduce using rule 45 (exp -> NOT exp .)
    MULTIPLY        reduce using rule 45 (exp -> NOT exp .)
    DIVIDE          reduce using rule 45 (exp -> NOT exp .)
    POWER           reduce using rule 45 (exp -> NOT exp .)
    MODULUS         reduce using rule 45 (exp -> NOT exp .)
    AND             reduce using rule 45 (exp -> NOT exp .)
    OR              reduce using rule 45 (exp -> NOT exp .)
    GT              reduce using rule 45 (exp -> NOT exp .)
    LT              reduce using rule 45 (exp -> NOT exp .)
    GTE             reduce using rule 45 (exp -> NOT exp .)
    LTE             reduce using rule 45 (exp -> NOT exp .)
    EE              reduce using rule 45 (exp -> NOT exp .)
    NE              reduce using rule 45 (exp -> NOT exp .)
    DEC             reduce using rule 45 (exp -> NOT exp .)
    INC             reduce using rule 45 (exp -> NOT exp .)
    SEMICOL         reduce using rule 45 (exp -> NOT exp .)
    error           reduce using rule 45 (exp -> NOT exp .)
    NAME            reduce using rule 45 (exp -> NOT exp .)
    INT             reduce using rule 45 (exp -> NOT exp .)
    FLOAT           reduce using rule 45 (exp -> NOT exp .)
    NOT             reduce using rule 45 (exp -> NOT exp .)
    TRUE            reduce using rule 45 (exp -> NOT exp .)
    FALSE           reduce using rule 45 (exp -> NOT exp .)
    STRING          reduce using rule 45 (exp -> NOT exp .)
    LPAREN          reduce using rule 45 (exp -> NOT exp .)
    MAKE            reduce using rule 45 (exp -> NOT exp .)
    IF              reduce using rule 45 (exp -> NOT exp .)
    FOR             reduce using rule 45 (exp -> NOT exp .)
    PRINT           reduce using rule 45 (exp -> NOT exp .)
    RETURN          reduce using rule 45 (exp -> NOT exp .)
    $end            reduce using rule 45 (exp -> NOT exp .)
    RPAREN          reduce using rule 45 (exp -> NOT exp .)
    THEN            reduce using rule 45 (exp -> NOT exp .)
    COMMA           reduce using rule 45 (exp -> NOT exp .)
    TO              reduce using rule 45 (exp -> NOT exp .)

  ! PLUS            [ shift and go to state 31 ]
  ! MINUS           [ shift and go to state 32 ]
  ! MULTIPLY        [ shift and go to state 33 ]
  ! DIVIDE          [ shift and go to state 34 ]
  ! POWER           [ shift and go to state 35 ]
  ! MODULUS         [ shift and go to state 36 ]
  ! AND             [ shift and go to state 37 ]
  ! OR              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 39 ]
  ! LT              [ shift and go to state 40 ]
  ! GTE             [ shift and go to state 41 ]
  ! LTE             [ shift and go to state 42 ]
  ! EE              [ shift and go to state 43 ]
  ! NE              [ shift and go to state 44 ]


state 56

    (50) makevar -> MAKE NAME .
    (52) assignment -> NAME . EQUAL exp

    SEMICOL         reduce using rule 50 (makevar -> MAKE NAME .)
    error           reduce using rule 50 (makevar -> MAKE NAME .)
    NAME            reduce using rule 50 (makevar -> MAKE NAME .)
    MINUS           reduce using rule 50 (makevar -> MAKE NAME .)
    INT             reduce using rule 50 (makevar -> MAKE NAME .)
    FLOAT           reduce using rule 50 (makevar -> MAKE NAME .)
    DEC             reduce using rule 50 (makevar -> MAKE NAME .)
    INC             reduce using rule 50 (makevar -> MAKE NAME .)
    NOT             reduce using rule 50 (makevar -> MAKE NAME .)
    TRUE            reduce using rule 50 (makevar -> MAKE NAME .)
    FALSE           reduce using rule 50 (makevar -> MAKE NAME .)
    STRING          reduce using rule 50 (makevar -> MAKE NAME .)
    LPAREN          reduce using rule 50 (makevar -> MAKE NAME .)
    MAKE            reduce using rule 50 (makevar -> MAKE NAME .)
    IF              reduce using rule 50 (makevar -> MAKE NAME .)
    FOR             reduce using rule 50 (makevar -> MAKE NAME .)
    PRINT           reduce using rule 50 (makevar -> MAKE NAME .)
    RETURN          reduce using rule 50 (makevar -> MAKE NAME .)
    $end            reduce using rule 50 (makevar -> MAKE NAME .)
    TO              reduce using rule 50 (makevar -> MAKE NAME .)
    EQUAL           shift and go to state 48


state 57

    (51) makevar -> MAKE assignment .

    SEMICOL         reduce using rule 51 (makevar -> MAKE assignment .)
    error           reduce using rule 51 (makevar -> MAKE assignment .)
    NAME            reduce using rule 51 (makevar -> MAKE assignment .)
    MINUS           reduce using rule 51 (makevar -> MAKE assignment .)
    INT             reduce using rule 51 (makevar -> MAKE assignment .)
    FLOAT           reduce using rule 51 (makevar -> MAKE assignment .)
    DEC             reduce using rule 51 (makevar -> MAKE assignment .)
    INC             reduce using rule 51 (makevar -> MAKE assignment .)
    NOT             reduce using rule 51 (makevar -> MAKE assignment .)
    TRUE            reduce using rule 51 (makevar -> MAKE assignment .)
    FALSE           reduce using rule 51 (makevar -> MAKE assignment .)
    STRING          reduce using rule 51 (makevar -> MAKE assignment .)
    LPAREN          reduce using rule 51 (makevar -> MAKE assignment .)
    MAKE            reduce using rule 51 (makevar -> MAKE assignment .)
    IF              reduce using rule 51 (makevar -> MAKE assignment .)
    FOR             reduce using rule 51 (makevar -> MAKE assignment .)
    PRINT           reduce using rule 51 (makevar -> MAKE assignment .)
    RETURN          reduce using rule 51 (makevar -> MAKE assignment .)
    $end            reduce using rule 51 (makevar -> MAKE assignment .)
    TO              reduce using rule 51 (makevar -> MAKE assignment .)


state 58

    (53) if -> IF exp . THEN stmtblock
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

    THEN            shift and go to state 83
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    POWER           shift and go to state 35
    MODULUS         shift and go to state 36
    AND             shift and go to state 37
    OR              shift and go to state 38
    GT              shift and go to state 39
    LT              shift and go to state 40
    GTE             shift and go to state 41
    LTE             shift and go to state 42
    EE              shift and go to state 43
    NE              shift and go to state 44


state 59

    (56) for -> FOR assignment . TO INT UNTIL

    TO              shift and go to state 84


state 60

    (57) for -> FOR makevar . TO INT UNTIL

    TO              shift and go to state 85


state 61

    (52) assignment -> NAME . EQUAL exp

    EQUAL           shift and go to state 48


state 62

    (58) print -> PRINT LPAREN . exp RPAREN
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 86

state 63

    (59) return -> RETURN exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOL         reduce using rule 59 (return -> RETURN exp .)
    error           reduce using rule 59 (return -> RETURN exp .)
    NAME            reduce using rule 59 (return -> RETURN exp .)
    INT             reduce using rule 59 (return -> RETURN exp .)
    FLOAT           reduce using rule 59 (return -> RETURN exp .)
    DEC             reduce using rule 59 (return -> RETURN exp .)
    INC             reduce using rule 59 (return -> RETURN exp .)
    NOT             reduce using rule 59 (return -> RETURN exp .)
    TRUE            reduce using rule 59 (return -> RETURN exp .)
    FALSE           reduce using rule 59 (return -> RETURN exp .)
    STRING          reduce using rule 59 (return -> RETURN exp .)
    LPAREN          reduce using rule 59 (return -> RETURN exp .)
    MAKE            reduce using rule 59 (return -> RETURN exp .)
    IF              reduce using rule 59 (return -> RETURN exp .)
    FOR             reduce using rule 59 (return -> RETURN exp .)
    PRINT           reduce using rule 59 (return -> RETURN exp .)
    RETURN          reduce using rule 59 (return -> RETURN exp .)
    $end            reduce using rule 59 (return -> RETURN exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    POWER           shift and go to state 35
    MODULUS         shift and go to state 36
    AND             shift and go to state 37
    OR              shift and go to state 38
    GT              shift and go to state 39
    LT              shift and go to state 40
    GTE             shift and go to state 41
    LTE             shift and go to state 42
    EE              shift and go to state 43
    NE              shift and go to state 44

  ! MINUS           [ reduce using rule 59 (return -> RETURN exp .) ]


state 64

    (22) exp -> exp PLUS exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

    PLUS            reduce using rule 22 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 22 (exp -> exp PLUS exp .)
    POWER           reduce using rule 22 (exp -> exp PLUS exp .)
    MODULUS         reduce using rule 22 (exp -> exp PLUS exp .)
    AND             reduce using rule 22 (exp -> exp PLUS exp .)
    OR              reduce using rule 22 (exp -> exp PLUS exp .)
    GT              reduce using rule 22 (exp -> exp PLUS exp .)
    LT              reduce using rule 22 (exp -> exp PLUS exp .)
    GTE             reduce using rule 22 (exp -> exp PLUS exp .)
    LTE             reduce using rule 22 (exp -> exp PLUS exp .)
    EE              reduce using rule 22 (exp -> exp PLUS exp .)
    NE              reduce using rule 22 (exp -> exp PLUS exp .)
    DEC             reduce using rule 22 (exp -> exp PLUS exp .)
    INC             reduce using rule 22 (exp -> exp PLUS exp .)
    SEMICOL         reduce using rule 22 (exp -> exp PLUS exp .)
    error           reduce using rule 22 (exp -> exp PLUS exp .)
    NAME            reduce using rule 22 (exp -> exp PLUS exp .)
    INT             reduce using rule 22 (exp -> exp PLUS exp .)
    FLOAT           reduce using rule 22 (exp -> exp PLUS exp .)
    NOT             reduce using rule 22 (exp -> exp PLUS exp .)
    TRUE            reduce using rule 22 (exp -> exp PLUS exp .)
    FALSE           reduce using rule 22 (exp -> exp PLUS exp .)
    STRING          reduce using rule 22 (exp -> exp PLUS exp .)
    LPAREN          reduce using rule 22 (exp -> exp PLUS exp .)
    MAKE            reduce using rule 22 (exp -> exp PLUS exp .)
    IF              reduce using rule 22 (exp -> exp PLUS exp .)
    FOR             reduce using rule 22 (exp -> exp PLUS exp .)
    PRINT           reduce using rule 22 (exp -> exp PLUS exp .)
    RETURN          reduce using rule 22 (exp -> exp PLUS exp .)
    $end            reduce using rule 22 (exp -> exp PLUS exp .)
    RPAREN          reduce using rule 22 (exp -> exp PLUS exp .)
    THEN            reduce using rule 22 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 22 (exp -> exp PLUS exp .)
    TO              reduce using rule 22 (exp -> exp PLUS exp .)
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34

  ! MULTIPLY        [ reduce using rule 22 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 22 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 31 ]
  ! MINUS           [ shift and go to state 32 ]
  ! POWER           [ shift and go to state 35 ]
  ! MODULUS         [ shift and go to state 36 ]
  ! AND             [ shift and go to state 37 ]
  ! OR              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 39 ]
  ! LT              [ shift and go to state 40 ]
  ! GTE             [ shift and go to state 41 ]
  ! LTE             [ shift and go to state 42 ]
  ! EE              [ shift and go to state 43 ]
  ! NE              [ shift and go to state 44 ]


state 65

    (23) exp -> exp MINUS exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

    PLUS            reduce using rule 23 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 23 (exp -> exp MINUS exp .)
    POWER           reduce using rule 23 (exp -> exp MINUS exp .)
    MODULUS         reduce using rule 23 (exp -> exp MINUS exp .)
    AND             reduce using rule 23 (exp -> exp MINUS exp .)
    OR              reduce using rule 23 (exp -> exp MINUS exp .)
    GT              reduce using rule 23 (exp -> exp MINUS exp .)
    LT              reduce using rule 23 (exp -> exp MINUS exp .)
    GTE             reduce using rule 23 (exp -> exp MINUS exp .)
    LTE             reduce using rule 23 (exp -> exp MINUS exp .)
    EE              reduce using rule 23 (exp -> exp MINUS exp .)
    NE              reduce using rule 23 (exp -> exp MINUS exp .)
    DEC             reduce using rule 23 (exp -> exp MINUS exp .)
    INC             reduce using rule 23 (exp -> exp MINUS exp .)
    SEMICOL         reduce using rule 23 (exp -> exp MINUS exp .)
    error           reduce using rule 23 (exp -> exp MINUS exp .)
    NAME            reduce using rule 23 (exp -> exp MINUS exp .)
    INT             reduce using rule 23 (exp -> exp MINUS exp .)
    FLOAT           reduce using rule 23 (exp -> exp MINUS exp .)
    NOT             reduce using rule 23 (exp -> exp MINUS exp .)
    TRUE            reduce using rule 23 (exp -> exp MINUS exp .)
    FALSE           reduce using rule 23 (exp -> exp MINUS exp .)
    STRING          reduce using rule 23 (exp -> exp MINUS exp .)
    LPAREN          reduce using rule 23 (exp -> exp MINUS exp .)
    MAKE            reduce using rule 23 (exp -> exp MINUS exp .)
    IF              reduce using rule 23 (exp -> exp MINUS exp .)
    FOR             reduce using rule 23 (exp -> exp MINUS exp .)
    PRINT           reduce using rule 23 (exp -> exp MINUS exp .)
    RETURN          reduce using rule 23 (exp -> exp MINUS exp .)
    $end            reduce using rule 23 (exp -> exp MINUS exp .)
    RPAREN          reduce using rule 23 (exp -> exp MINUS exp .)
    THEN            reduce using rule 23 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 23 (exp -> exp MINUS exp .)
    TO              reduce using rule 23 (exp -> exp MINUS exp .)
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34

  ! MULTIPLY        [ reduce using rule 23 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 23 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 31 ]
  ! MINUS           [ shift and go to state 32 ]
  ! POWER           [ shift and go to state 35 ]
  ! MODULUS         [ shift and go to state 36 ]
  ! AND             [ shift and go to state 37 ]
  ! OR              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 39 ]
  ! LT              [ shift and go to state 40 ]
  ! GTE             [ shift and go to state 41 ]
  ! LTE             [ shift and go to state 42 ]
  ! EE              [ shift and go to state 43 ]
  ! NE              [ shift and go to state 44 ]


state 66

    (24) exp -> exp MULTIPLY exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

    PLUS            reduce using rule 24 (exp -> exp MULTIPLY exp .)
    MINUS           reduce using rule 24 (exp -> exp MULTIPLY exp .)
    MULTIPLY        reduce using rule 24 (exp -> exp MULTIPLY exp .)
    DIVIDE          reduce using rule 24 (exp -> exp MULTIPLY exp .)
    POWER           reduce using rule 24 (exp -> exp MULTIPLY exp .)
    MODULUS         reduce using rule 24 (exp -> exp MULTIPLY exp .)
    AND             reduce using rule 24 (exp -> exp MULTIPLY exp .)
    OR              reduce using rule 24 (exp -> exp MULTIPLY exp .)
    GT              reduce using rule 24 (exp -> exp MULTIPLY exp .)
    LT              reduce using rule 24 (exp -> exp MULTIPLY exp .)
    GTE             reduce using rule 24 (exp -> exp MULTIPLY exp .)
    LTE             reduce using rule 24 (exp -> exp MULTIPLY exp .)
    EE              reduce using rule 24 (exp -> exp MULTIPLY exp .)
    NE              reduce using rule 24 (exp -> exp MULTIPLY exp .)
    DEC             reduce using rule 24 (exp -> exp MULTIPLY exp .)
    INC             reduce using rule 24 (exp -> exp MULTIPLY exp .)
    SEMICOL         reduce using rule 24 (exp -> exp MULTIPLY exp .)
    error           reduce using rule 24 (exp -> exp MULTIPLY exp .)
    NAME            reduce using rule 24 (exp -> exp MULTIPLY exp .)
    INT             reduce using rule 24 (exp -> exp MULTIPLY exp .)
    FLOAT           reduce using rule 24 (exp -> exp MULTIPLY exp .)
    NOT             reduce using rule 24 (exp -> exp MULTIPLY exp .)
    TRUE            reduce using rule 24 (exp -> exp MULTIPLY exp .)
    FALSE           reduce using rule 24 (exp -> exp MULTIPLY exp .)
    STRING          reduce using rule 24 (exp -> exp MULTIPLY exp .)
    LPAREN          reduce using rule 24 (exp -> exp MULTIPLY exp .)
    MAKE            reduce using rule 24 (exp -> exp MULTIPLY exp .)
    IF              reduce using rule 24 (exp -> exp MULTIPLY exp .)
    FOR             reduce using rule 24 (exp -> exp MULTIPLY exp .)
    PRINT           reduce using rule 24 (exp -> exp MULTIPLY exp .)
    RETURN          reduce using rule 24 (exp -> exp MULTIPLY exp .)
    $end            reduce using rule 24 (exp -> exp MULTIPLY exp .)
    RPAREN          reduce using rule 24 (exp -> exp MULTIPLY exp .)
    THEN            reduce using rule 24 (exp -> exp MULTIPLY exp .)
    COMMA           reduce using rule 24 (exp -> exp MULTIPLY exp .)
    TO              reduce using rule 24 (exp -> exp MULTIPLY exp .)

  ! PLUS            [ shift and go to state 31 ]
  ! MINUS           [ shift and go to state 32 ]
  ! MULTIPLY        [ shift and go to state 33 ]
  ! DIVIDE          [ shift and go to state 34 ]
  ! POWER           [ shift and go to state 35 ]
  ! MODULUS         [ shift and go to state 36 ]
  ! AND             [ shift and go to state 37 ]
  ! OR              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 39 ]
  ! LT              [ shift and go to state 40 ]
  ! GTE             [ shift and go to state 41 ]
  ! LTE             [ shift and go to state 42 ]
  ! EE              [ shift and go to state 43 ]
  ! NE              [ shift and go to state 44 ]


state 67

    (25) exp -> exp DIVIDE exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

    PLUS            reduce using rule 25 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 25 (exp -> exp DIVIDE exp .)
    MULTIPLY        reduce using rule 25 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 25 (exp -> exp DIVIDE exp .)
    POWER           reduce using rule 25 (exp -> exp DIVIDE exp .)
    MODULUS         reduce using rule 25 (exp -> exp DIVIDE exp .)
    AND             reduce using rule 25 (exp -> exp DIVIDE exp .)
    OR              reduce using rule 25 (exp -> exp DIVIDE exp .)
    GT              reduce using rule 25 (exp -> exp DIVIDE exp .)
    LT              reduce using rule 25 (exp -> exp DIVIDE exp .)
    GTE             reduce using rule 25 (exp -> exp DIVIDE exp .)
    LTE             reduce using rule 25 (exp -> exp DIVIDE exp .)
    EE              reduce using rule 25 (exp -> exp DIVIDE exp .)
    NE              reduce using rule 25 (exp -> exp DIVIDE exp .)
    DEC             reduce using rule 25 (exp -> exp DIVIDE exp .)
    INC             reduce using rule 25 (exp -> exp DIVIDE exp .)
    SEMICOL         reduce using rule 25 (exp -> exp DIVIDE exp .)
    error           reduce using rule 25 (exp -> exp DIVIDE exp .)
    NAME            reduce using rule 25 (exp -> exp DIVIDE exp .)
    INT             reduce using rule 25 (exp -> exp DIVIDE exp .)
    FLOAT           reduce using rule 25 (exp -> exp DIVIDE exp .)
    NOT             reduce using rule 25 (exp -> exp DIVIDE exp .)
    TRUE            reduce using rule 25 (exp -> exp DIVIDE exp .)
    FALSE           reduce using rule 25 (exp -> exp DIVIDE exp .)
    STRING          reduce using rule 25 (exp -> exp DIVIDE exp .)
    LPAREN          reduce using rule 25 (exp -> exp DIVIDE exp .)
    MAKE            reduce using rule 25 (exp -> exp DIVIDE exp .)
    IF              reduce using rule 25 (exp -> exp DIVIDE exp .)
    FOR             reduce using rule 25 (exp -> exp DIVIDE exp .)
    PRINT           reduce using rule 25 (exp -> exp DIVIDE exp .)
    RETURN          reduce using rule 25 (exp -> exp DIVIDE exp .)
    $end            reduce using rule 25 (exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 25 (exp -> exp DIVIDE exp .)
    THEN            reduce using rule 25 (exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 25 (exp -> exp DIVIDE exp .)
    TO              reduce using rule 25 (exp -> exp DIVIDE exp .)

  ! PLUS            [ shift and go to state 31 ]
  ! MINUS           [ shift and go to state 32 ]
  ! MULTIPLY        [ shift and go to state 33 ]
  ! DIVIDE          [ shift and go to state 34 ]
  ! POWER           [ shift and go to state 35 ]
  ! MODULUS         [ shift and go to state 36 ]
  ! AND             [ shift and go to state 37 ]
  ! OR              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 39 ]
  ! LT              [ shift and go to state 40 ]
  ! GTE             [ shift and go to state 41 ]
  ! LTE             [ shift and go to state 42 ]
  ! EE              [ shift and go to state 43 ]
  ! NE              [ shift and go to state 44 ]


state 68

    (26) exp -> exp POWER exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for EE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    DEC             reduce using rule 26 (exp -> exp POWER exp .)
    INC             reduce using rule 26 (exp -> exp POWER exp .)
    SEMICOL         reduce using rule 26 (exp -> exp POWER exp .)
    error           reduce using rule 26 (exp -> exp POWER exp .)
    NAME            reduce using rule 26 (exp -> exp POWER exp .)
    INT             reduce using rule 26 (exp -> exp POWER exp .)
    FLOAT           reduce using rule 26 (exp -> exp POWER exp .)
    NOT             reduce using rule 26 (exp -> exp POWER exp .)
    TRUE            reduce using rule 26 (exp -> exp POWER exp .)
    FALSE           reduce using rule 26 (exp -> exp POWER exp .)
    STRING          reduce using rule 26 (exp -> exp POWER exp .)
    LPAREN          reduce using rule 26 (exp -> exp POWER exp .)
    MAKE            reduce using rule 26 (exp -> exp POWER exp .)
    IF              reduce using rule 26 (exp -> exp POWER exp .)
    FOR             reduce using rule 26 (exp -> exp POWER exp .)
    PRINT           reduce using rule 26 (exp -> exp POWER exp .)
    RETURN          reduce using rule 26 (exp -> exp POWER exp .)
    $end            reduce using rule 26 (exp -> exp POWER exp .)
    RPAREN          reduce using rule 26 (exp -> exp POWER exp .)
    THEN            reduce using rule 26 (exp -> exp POWER exp .)
    COMMA           reduce using rule 26 (exp -> exp POWER exp .)
    TO              reduce using rule 26 (exp -> exp POWER exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    POWER           shift and go to state 35
    MODULUS         shift and go to state 36
    AND             shift and go to state 37
    OR              shift and go to state 38
    GT              shift and go to state 39
    LT              shift and go to state 40
    GTE             shift and go to state 41
    LTE             shift and go to state 42
    EE              shift and go to state 43
    NE              shift and go to state 44

  ! PLUS            [ reduce using rule 26 (exp -> exp POWER exp .) ]
  ! MINUS           [ reduce using rule 26 (exp -> exp POWER exp .) ]
  ! MULTIPLY        [ reduce using rule 26 (exp -> exp POWER exp .) ]
  ! DIVIDE          [ reduce using rule 26 (exp -> exp POWER exp .) ]
  ! POWER           [ reduce using rule 26 (exp -> exp POWER exp .) ]
  ! MODULUS         [ reduce using rule 26 (exp -> exp POWER exp .) ]
  ! AND             [ reduce using rule 26 (exp -> exp POWER exp .) ]
  ! OR              [ reduce using rule 26 (exp -> exp POWER exp .) ]
  ! GT              [ reduce using rule 26 (exp -> exp POWER exp .) ]
  ! LT              [ reduce using rule 26 (exp -> exp POWER exp .) ]
  ! GTE             [ reduce using rule 26 (exp -> exp POWER exp .) ]
  ! LTE             [ reduce using rule 26 (exp -> exp POWER exp .) ]
  ! EE              [ reduce using rule 26 (exp -> exp POWER exp .) ]
  ! NE              [ reduce using rule 26 (exp -> exp POWER exp .) ]


state 69

    (27) exp -> exp MODULUS exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for EE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    DEC             reduce using rule 27 (exp -> exp MODULUS exp .)
    INC             reduce using rule 27 (exp -> exp MODULUS exp .)
    SEMICOL         reduce using rule 27 (exp -> exp MODULUS exp .)
    error           reduce using rule 27 (exp -> exp MODULUS exp .)
    NAME            reduce using rule 27 (exp -> exp MODULUS exp .)
    INT             reduce using rule 27 (exp -> exp MODULUS exp .)
    FLOAT           reduce using rule 27 (exp -> exp MODULUS exp .)
    NOT             reduce using rule 27 (exp -> exp MODULUS exp .)
    TRUE            reduce using rule 27 (exp -> exp MODULUS exp .)
    FALSE           reduce using rule 27 (exp -> exp MODULUS exp .)
    STRING          reduce using rule 27 (exp -> exp MODULUS exp .)
    LPAREN          reduce using rule 27 (exp -> exp MODULUS exp .)
    MAKE            reduce using rule 27 (exp -> exp MODULUS exp .)
    IF              reduce using rule 27 (exp -> exp MODULUS exp .)
    FOR             reduce using rule 27 (exp -> exp MODULUS exp .)
    PRINT           reduce using rule 27 (exp -> exp MODULUS exp .)
    RETURN          reduce using rule 27 (exp -> exp MODULUS exp .)
    $end            reduce using rule 27 (exp -> exp MODULUS exp .)
    RPAREN          reduce using rule 27 (exp -> exp MODULUS exp .)
    THEN            reduce using rule 27 (exp -> exp MODULUS exp .)
    COMMA           reduce using rule 27 (exp -> exp MODULUS exp .)
    TO              reduce using rule 27 (exp -> exp MODULUS exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    POWER           shift and go to state 35
    MODULUS         shift and go to state 36
    AND             shift and go to state 37
    OR              shift and go to state 38
    GT              shift and go to state 39
    LT              shift and go to state 40
    GTE             shift and go to state 41
    LTE             shift and go to state 42
    EE              shift and go to state 43
    NE              shift and go to state 44

  ! PLUS            [ reduce using rule 27 (exp -> exp MODULUS exp .) ]
  ! MINUS           [ reduce using rule 27 (exp -> exp MODULUS exp .) ]
  ! MULTIPLY        [ reduce using rule 27 (exp -> exp MODULUS exp .) ]
  ! DIVIDE          [ reduce using rule 27 (exp -> exp MODULUS exp .) ]
  ! POWER           [ reduce using rule 27 (exp -> exp MODULUS exp .) ]
  ! MODULUS         [ reduce using rule 27 (exp -> exp MODULUS exp .) ]
  ! AND             [ reduce using rule 27 (exp -> exp MODULUS exp .) ]
  ! OR              [ reduce using rule 27 (exp -> exp MODULUS exp .) ]
  ! GT              [ reduce using rule 27 (exp -> exp MODULUS exp .) ]
  ! LT              [ reduce using rule 27 (exp -> exp MODULUS exp .) ]
  ! GTE             [ reduce using rule 27 (exp -> exp MODULUS exp .) ]
  ! LTE             [ reduce using rule 27 (exp -> exp MODULUS exp .) ]
  ! EE              [ reduce using rule 27 (exp -> exp MODULUS exp .) ]
  ! NE              [ reduce using rule 27 (exp -> exp MODULUS exp .) ]


state 70

    (28) exp -> exp AND exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

    POWER           reduce using rule 28 (exp -> exp AND exp .)
    MODULUS         reduce using rule 28 (exp -> exp AND exp .)
    AND             reduce using rule 28 (exp -> exp AND exp .)
    OR              reduce using rule 28 (exp -> exp AND exp .)
    DEC             reduce using rule 28 (exp -> exp AND exp .)
    INC             reduce using rule 28 (exp -> exp AND exp .)
    SEMICOL         reduce using rule 28 (exp -> exp AND exp .)
    error           reduce using rule 28 (exp -> exp AND exp .)
    NAME            reduce using rule 28 (exp -> exp AND exp .)
    INT             reduce using rule 28 (exp -> exp AND exp .)
    FLOAT           reduce using rule 28 (exp -> exp AND exp .)
    NOT             reduce using rule 28 (exp -> exp AND exp .)
    TRUE            reduce using rule 28 (exp -> exp AND exp .)
    FALSE           reduce using rule 28 (exp -> exp AND exp .)
    STRING          reduce using rule 28 (exp -> exp AND exp .)
    LPAREN          reduce using rule 28 (exp -> exp AND exp .)
    MAKE            reduce using rule 28 (exp -> exp AND exp .)
    IF              reduce using rule 28 (exp -> exp AND exp .)
    FOR             reduce using rule 28 (exp -> exp AND exp .)
    PRINT           reduce using rule 28 (exp -> exp AND exp .)
    RETURN          reduce using rule 28 (exp -> exp AND exp .)
    $end            reduce using rule 28 (exp -> exp AND exp .)
    RPAREN          reduce using rule 28 (exp -> exp AND exp .)
    THEN            reduce using rule 28 (exp -> exp AND exp .)
    COMMA           reduce using rule 28 (exp -> exp AND exp .)
    TO              reduce using rule 28 (exp -> exp AND exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    GT              shift and go to state 39
    LT              shift and go to state 40
    GTE             shift and go to state 41
    LTE             shift and go to state 42
    EE              shift and go to state 43
    NE              shift and go to state 44

  ! PLUS            [ reduce using rule 28 (exp -> exp AND exp .) ]
  ! MINUS           [ reduce using rule 28 (exp -> exp AND exp .) ]
  ! MULTIPLY        [ reduce using rule 28 (exp -> exp AND exp .) ]
  ! DIVIDE          [ reduce using rule 28 (exp -> exp AND exp .) ]
  ! GT              [ reduce using rule 28 (exp -> exp AND exp .) ]
  ! LT              [ reduce using rule 28 (exp -> exp AND exp .) ]
  ! GTE             [ reduce using rule 28 (exp -> exp AND exp .) ]
  ! LTE             [ reduce using rule 28 (exp -> exp AND exp .) ]
  ! EE              [ reduce using rule 28 (exp -> exp AND exp .) ]
  ! NE              [ reduce using rule 28 (exp -> exp AND exp .) ]
  ! POWER           [ shift and go to state 35 ]
  ! MODULUS         [ shift and go to state 36 ]
  ! AND             [ shift and go to state 37 ]
  ! OR              [ shift and go to state 38 ]


state 71

    (29) exp -> exp OR exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

    POWER           reduce using rule 29 (exp -> exp OR exp .)
    MODULUS         reduce using rule 29 (exp -> exp OR exp .)
    OR              reduce using rule 29 (exp -> exp OR exp .)
    DEC             reduce using rule 29 (exp -> exp OR exp .)
    INC             reduce using rule 29 (exp -> exp OR exp .)
    SEMICOL         reduce using rule 29 (exp -> exp OR exp .)
    error           reduce using rule 29 (exp -> exp OR exp .)
    NAME            reduce using rule 29 (exp -> exp OR exp .)
    INT             reduce using rule 29 (exp -> exp OR exp .)
    FLOAT           reduce using rule 29 (exp -> exp OR exp .)
    NOT             reduce using rule 29 (exp -> exp OR exp .)
    TRUE            reduce using rule 29 (exp -> exp OR exp .)
    FALSE           reduce using rule 29 (exp -> exp OR exp .)
    STRING          reduce using rule 29 (exp -> exp OR exp .)
    LPAREN          reduce using rule 29 (exp -> exp OR exp .)
    MAKE            reduce using rule 29 (exp -> exp OR exp .)
    IF              reduce using rule 29 (exp -> exp OR exp .)
    FOR             reduce using rule 29 (exp -> exp OR exp .)
    PRINT           reduce using rule 29 (exp -> exp OR exp .)
    RETURN          reduce using rule 29 (exp -> exp OR exp .)
    $end            reduce using rule 29 (exp -> exp OR exp .)
    RPAREN          reduce using rule 29 (exp -> exp OR exp .)
    THEN            reduce using rule 29 (exp -> exp OR exp .)
    COMMA           reduce using rule 29 (exp -> exp OR exp .)
    TO              reduce using rule 29 (exp -> exp OR exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    AND             shift and go to state 37
    GT              shift and go to state 39
    LT              shift and go to state 40
    GTE             shift and go to state 41
    LTE             shift and go to state 42
    EE              shift and go to state 43
    NE              shift and go to state 44

  ! PLUS            [ reduce using rule 29 (exp -> exp OR exp .) ]
  ! MINUS           [ reduce using rule 29 (exp -> exp OR exp .) ]
  ! MULTIPLY        [ reduce using rule 29 (exp -> exp OR exp .) ]
  ! DIVIDE          [ reduce using rule 29 (exp -> exp OR exp .) ]
  ! AND             [ reduce using rule 29 (exp -> exp OR exp .) ]
  ! GT              [ reduce using rule 29 (exp -> exp OR exp .) ]
  ! LT              [ reduce using rule 29 (exp -> exp OR exp .) ]
  ! GTE             [ reduce using rule 29 (exp -> exp OR exp .) ]
  ! LTE             [ reduce using rule 29 (exp -> exp OR exp .) ]
  ! EE              [ reduce using rule 29 (exp -> exp OR exp .) ]
  ! NE              [ reduce using rule 29 (exp -> exp OR exp .) ]
  ! POWER           [ shift and go to state 35 ]
  ! MODULUS         [ shift and go to state 36 ]
  ! OR              [ shift and go to state 38 ]


state 72

    (30) exp -> exp GT exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

    POWER           reduce using rule 30 (exp -> exp GT exp .)
    MODULUS         reduce using rule 30 (exp -> exp GT exp .)
    AND             reduce using rule 30 (exp -> exp GT exp .)
    OR              reduce using rule 30 (exp -> exp GT exp .)
    GT              reduce using rule 30 (exp -> exp GT exp .)
    LT              reduce using rule 30 (exp -> exp GT exp .)
    GTE             reduce using rule 30 (exp -> exp GT exp .)
    LTE             reduce using rule 30 (exp -> exp GT exp .)
    EE              reduce using rule 30 (exp -> exp GT exp .)
    NE              reduce using rule 30 (exp -> exp GT exp .)
    DEC             reduce using rule 30 (exp -> exp GT exp .)
    INC             reduce using rule 30 (exp -> exp GT exp .)
    SEMICOL         reduce using rule 30 (exp -> exp GT exp .)
    error           reduce using rule 30 (exp -> exp GT exp .)
    NAME            reduce using rule 30 (exp -> exp GT exp .)
    INT             reduce using rule 30 (exp -> exp GT exp .)
    FLOAT           reduce using rule 30 (exp -> exp GT exp .)
    NOT             reduce using rule 30 (exp -> exp GT exp .)
    TRUE            reduce using rule 30 (exp -> exp GT exp .)
    FALSE           reduce using rule 30 (exp -> exp GT exp .)
    STRING          reduce using rule 30 (exp -> exp GT exp .)
    LPAREN          reduce using rule 30 (exp -> exp GT exp .)
    MAKE            reduce using rule 30 (exp -> exp GT exp .)
    IF              reduce using rule 30 (exp -> exp GT exp .)
    FOR             reduce using rule 30 (exp -> exp GT exp .)
    PRINT           reduce using rule 30 (exp -> exp GT exp .)
    RETURN          reduce using rule 30 (exp -> exp GT exp .)
    $end            reduce using rule 30 (exp -> exp GT exp .)
    RPAREN          reduce using rule 30 (exp -> exp GT exp .)
    THEN            reduce using rule 30 (exp -> exp GT exp .)
    COMMA           reduce using rule 30 (exp -> exp GT exp .)
    TO              reduce using rule 30 (exp -> exp GT exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34

  ! PLUS            [ reduce using rule 30 (exp -> exp GT exp .) ]
  ! MINUS           [ reduce using rule 30 (exp -> exp GT exp .) ]
  ! MULTIPLY        [ reduce using rule 30 (exp -> exp GT exp .) ]
  ! DIVIDE          [ reduce using rule 30 (exp -> exp GT exp .) ]
  ! POWER           [ shift and go to state 35 ]
  ! MODULUS         [ shift and go to state 36 ]
  ! AND             [ shift and go to state 37 ]
  ! OR              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 39 ]
  ! LT              [ shift and go to state 40 ]
  ! GTE             [ shift and go to state 41 ]
  ! LTE             [ shift and go to state 42 ]
  ! EE              [ shift and go to state 43 ]
  ! NE              [ shift and go to state 44 ]


state 73

    (31) exp -> exp LT exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

    POWER           reduce using rule 31 (exp -> exp LT exp .)
    MODULUS         reduce using rule 31 (exp -> exp LT exp .)
    AND             reduce using rule 31 (exp -> exp LT exp .)
    OR              reduce using rule 31 (exp -> exp LT exp .)
    GT              reduce using rule 31 (exp -> exp LT exp .)
    LT              reduce using rule 31 (exp -> exp LT exp .)
    GTE             reduce using rule 31 (exp -> exp LT exp .)
    LTE             reduce using rule 31 (exp -> exp LT exp .)
    EE              reduce using rule 31 (exp -> exp LT exp .)
    NE              reduce using rule 31 (exp -> exp LT exp .)
    DEC             reduce using rule 31 (exp -> exp LT exp .)
    INC             reduce using rule 31 (exp -> exp LT exp .)
    SEMICOL         reduce using rule 31 (exp -> exp LT exp .)
    error           reduce using rule 31 (exp -> exp LT exp .)
    NAME            reduce using rule 31 (exp -> exp LT exp .)
    INT             reduce using rule 31 (exp -> exp LT exp .)
    FLOAT           reduce using rule 31 (exp -> exp LT exp .)
    NOT             reduce using rule 31 (exp -> exp LT exp .)
    TRUE            reduce using rule 31 (exp -> exp LT exp .)
    FALSE           reduce using rule 31 (exp -> exp LT exp .)
    STRING          reduce using rule 31 (exp -> exp LT exp .)
    LPAREN          reduce using rule 31 (exp -> exp LT exp .)
    MAKE            reduce using rule 31 (exp -> exp LT exp .)
    IF              reduce using rule 31 (exp -> exp LT exp .)
    FOR             reduce using rule 31 (exp -> exp LT exp .)
    PRINT           reduce using rule 31 (exp -> exp LT exp .)
    RETURN          reduce using rule 31 (exp -> exp LT exp .)
    $end            reduce using rule 31 (exp -> exp LT exp .)
    RPAREN          reduce using rule 31 (exp -> exp LT exp .)
    THEN            reduce using rule 31 (exp -> exp LT exp .)
    COMMA           reduce using rule 31 (exp -> exp LT exp .)
    TO              reduce using rule 31 (exp -> exp LT exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34

  ! PLUS            [ reduce using rule 31 (exp -> exp LT exp .) ]
  ! MINUS           [ reduce using rule 31 (exp -> exp LT exp .) ]
  ! MULTIPLY        [ reduce using rule 31 (exp -> exp LT exp .) ]
  ! DIVIDE          [ reduce using rule 31 (exp -> exp LT exp .) ]
  ! POWER           [ shift and go to state 35 ]
  ! MODULUS         [ shift and go to state 36 ]
  ! AND             [ shift and go to state 37 ]
  ! OR              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 39 ]
  ! LT              [ shift and go to state 40 ]
  ! GTE             [ shift and go to state 41 ]
  ! LTE             [ shift and go to state 42 ]
  ! EE              [ shift and go to state 43 ]
  ! NE              [ shift and go to state 44 ]


state 74

    (32) exp -> exp GTE exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

    POWER           reduce using rule 32 (exp -> exp GTE exp .)
    MODULUS         reduce using rule 32 (exp -> exp GTE exp .)
    AND             reduce using rule 32 (exp -> exp GTE exp .)
    OR              reduce using rule 32 (exp -> exp GTE exp .)
    GT              reduce using rule 32 (exp -> exp GTE exp .)
    LT              reduce using rule 32 (exp -> exp GTE exp .)
    GTE             reduce using rule 32 (exp -> exp GTE exp .)
    LTE             reduce using rule 32 (exp -> exp GTE exp .)
    EE              reduce using rule 32 (exp -> exp GTE exp .)
    NE              reduce using rule 32 (exp -> exp GTE exp .)
    DEC             reduce using rule 32 (exp -> exp GTE exp .)
    INC             reduce using rule 32 (exp -> exp GTE exp .)
    SEMICOL         reduce using rule 32 (exp -> exp GTE exp .)
    error           reduce using rule 32 (exp -> exp GTE exp .)
    NAME            reduce using rule 32 (exp -> exp GTE exp .)
    INT             reduce using rule 32 (exp -> exp GTE exp .)
    FLOAT           reduce using rule 32 (exp -> exp GTE exp .)
    NOT             reduce using rule 32 (exp -> exp GTE exp .)
    TRUE            reduce using rule 32 (exp -> exp GTE exp .)
    FALSE           reduce using rule 32 (exp -> exp GTE exp .)
    STRING          reduce using rule 32 (exp -> exp GTE exp .)
    LPAREN          reduce using rule 32 (exp -> exp GTE exp .)
    MAKE            reduce using rule 32 (exp -> exp GTE exp .)
    IF              reduce using rule 32 (exp -> exp GTE exp .)
    FOR             reduce using rule 32 (exp -> exp GTE exp .)
    PRINT           reduce using rule 32 (exp -> exp GTE exp .)
    RETURN          reduce using rule 32 (exp -> exp GTE exp .)
    $end            reduce using rule 32 (exp -> exp GTE exp .)
    RPAREN          reduce using rule 32 (exp -> exp GTE exp .)
    THEN            reduce using rule 32 (exp -> exp GTE exp .)
    COMMA           reduce using rule 32 (exp -> exp GTE exp .)
    TO              reduce using rule 32 (exp -> exp GTE exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34

  ! PLUS            [ reduce using rule 32 (exp -> exp GTE exp .) ]
  ! MINUS           [ reduce using rule 32 (exp -> exp GTE exp .) ]
  ! MULTIPLY        [ reduce using rule 32 (exp -> exp GTE exp .) ]
  ! DIVIDE          [ reduce using rule 32 (exp -> exp GTE exp .) ]
  ! POWER           [ shift and go to state 35 ]
  ! MODULUS         [ shift and go to state 36 ]
  ! AND             [ shift and go to state 37 ]
  ! OR              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 39 ]
  ! LT              [ shift and go to state 40 ]
  ! GTE             [ shift and go to state 41 ]
  ! LTE             [ shift and go to state 42 ]
  ! EE              [ shift and go to state 43 ]
  ! NE              [ shift and go to state 44 ]


state 75

    (33) exp -> exp LTE exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

    POWER           reduce using rule 33 (exp -> exp LTE exp .)
    MODULUS         reduce using rule 33 (exp -> exp LTE exp .)
    AND             reduce using rule 33 (exp -> exp LTE exp .)
    OR              reduce using rule 33 (exp -> exp LTE exp .)
    GT              reduce using rule 33 (exp -> exp LTE exp .)
    LT              reduce using rule 33 (exp -> exp LTE exp .)
    GTE             reduce using rule 33 (exp -> exp LTE exp .)
    LTE             reduce using rule 33 (exp -> exp LTE exp .)
    EE              reduce using rule 33 (exp -> exp LTE exp .)
    NE              reduce using rule 33 (exp -> exp LTE exp .)
    DEC             reduce using rule 33 (exp -> exp LTE exp .)
    INC             reduce using rule 33 (exp -> exp LTE exp .)
    SEMICOL         reduce using rule 33 (exp -> exp LTE exp .)
    error           reduce using rule 33 (exp -> exp LTE exp .)
    NAME            reduce using rule 33 (exp -> exp LTE exp .)
    INT             reduce using rule 33 (exp -> exp LTE exp .)
    FLOAT           reduce using rule 33 (exp -> exp LTE exp .)
    NOT             reduce using rule 33 (exp -> exp LTE exp .)
    TRUE            reduce using rule 33 (exp -> exp LTE exp .)
    FALSE           reduce using rule 33 (exp -> exp LTE exp .)
    STRING          reduce using rule 33 (exp -> exp LTE exp .)
    LPAREN          reduce using rule 33 (exp -> exp LTE exp .)
    MAKE            reduce using rule 33 (exp -> exp LTE exp .)
    IF              reduce using rule 33 (exp -> exp LTE exp .)
    FOR             reduce using rule 33 (exp -> exp LTE exp .)
    PRINT           reduce using rule 33 (exp -> exp LTE exp .)
    RETURN          reduce using rule 33 (exp -> exp LTE exp .)
    $end            reduce using rule 33 (exp -> exp LTE exp .)
    RPAREN          reduce using rule 33 (exp -> exp LTE exp .)
    THEN            reduce using rule 33 (exp -> exp LTE exp .)
    COMMA           reduce using rule 33 (exp -> exp LTE exp .)
    TO              reduce using rule 33 (exp -> exp LTE exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34

  ! PLUS            [ reduce using rule 33 (exp -> exp LTE exp .) ]
  ! MINUS           [ reduce using rule 33 (exp -> exp LTE exp .) ]
  ! MULTIPLY        [ reduce using rule 33 (exp -> exp LTE exp .) ]
  ! DIVIDE          [ reduce using rule 33 (exp -> exp LTE exp .) ]
  ! POWER           [ shift and go to state 35 ]
  ! MODULUS         [ shift and go to state 36 ]
  ! AND             [ shift and go to state 37 ]
  ! OR              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 39 ]
  ! LT              [ shift and go to state 40 ]
  ! GTE             [ shift and go to state 41 ]
  ! LTE             [ shift and go to state 42 ]
  ! EE              [ shift and go to state 43 ]
  ! NE              [ shift and go to state 44 ]


state 76

    (34) exp -> exp EE exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

    POWER           reduce using rule 34 (exp -> exp EE exp .)
    MODULUS         reduce using rule 34 (exp -> exp EE exp .)
    AND             reduce using rule 34 (exp -> exp EE exp .)
    OR              reduce using rule 34 (exp -> exp EE exp .)
    EE              reduce using rule 34 (exp -> exp EE exp .)
    NE              reduce using rule 34 (exp -> exp EE exp .)
    DEC             reduce using rule 34 (exp -> exp EE exp .)
    INC             reduce using rule 34 (exp -> exp EE exp .)
    SEMICOL         reduce using rule 34 (exp -> exp EE exp .)
    error           reduce using rule 34 (exp -> exp EE exp .)
    NAME            reduce using rule 34 (exp -> exp EE exp .)
    INT             reduce using rule 34 (exp -> exp EE exp .)
    FLOAT           reduce using rule 34 (exp -> exp EE exp .)
    NOT             reduce using rule 34 (exp -> exp EE exp .)
    TRUE            reduce using rule 34 (exp -> exp EE exp .)
    FALSE           reduce using rule 34 (exp -> exp EE exp .)
    STRING          reduce using rule 34 (exp -> exp EE exp .)
    LPAREN          reduce using rule 34 (exp -> exp EE exp .)
    MAKE            reduce using rule 34 (exp -> exp EE exp .)
    IF              reduce using rule 34 (exp -> exp EE exp .)
    FOR             reduce using rule 34 (exp -> exp EE exp .)
    PRINT           reduce using rule 34 (exp -> exp EE exp .)
    RETURN          reduce using rule 34 (exp -> exp EE exp .)
    $end            reduce using rule 34 (exp -> exp EE exp .)
    RPAREN          reduce using rule 34 (exp -> exp EE exp .)
    THEN            reduce using rule 34 (exp -> exp EE exp .)
    COMMA           reduce using rule 34 (exp -> exp EE exp .)
    TO              reduce using rule 34 (exp -> exp EE exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    GT              shift and go to state 39
    LT              shift and go to state 40
    GTE             shift and go to state 41
    LTE             shift and go to state 42

  ! PLUS            [ reduce using rule 34 (exp -> exp EE exp .) ]
  ! MINUS           [ reduce using rule 34 (exp -> exp EE exp .) ]
  ! MULTIPLY        [ reduce using rule 34 (exp -> exp EE exp .) ]
  ! DIVIDE          [ reduce using rule 34 (exp -> exp EE exp .) ]
  ! GT              [ reduce using rule 34 (exp -> exp EE exp .) ]
  ! LT              [ reduce using rule 34 (exp -> exp EE exp .) ]
  ! GTE             [ reduce using rule 34 (exp -> exp EE exp .) ]
  ! LTE             [ reduce using rule 34 (exp -> exp EE exp .) ]
  ! POWER           [ shift and go to state 35 ]
  ! MODULUS         [ shift and go to state 36 ]
  ! AND             [ shift and go to state 37 ]
  ! OR              [ shift and go to state 38 ]
  ! EE              [ shift and go to state 43 ]
  ! NE              [ shift and go to state 44 ]


state 77

    (35) exp -> exp NE exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

    POWER           reduce using rule 35 (exp -> exp NE exp .)
    MODULUS         reduce using rule 35 (exp -> exp NE exp .)
    AND             reduce using rule 35 (exp -> exp NE exp .)
    OR              reduce using rule 35 (exp -> exp NE exp .)
    EE              reduce using rule 35 (exp -> exp NE exp .)
    NE              reduce using rule 35 (exp -> exp NE exp .)
    DEC             reduce using rule 35 (exp -> exp NE exp .)
    INC             reduce using rule 35 (exp -> exp NE exp .)
    SEMICOL         reduce using rule 35 (exp -> exp NE exp .)
    error           reduce using rule 35 (exp -> exp NE exp .)
    NAME            reduce using rule 35 (exp -> exp NE exp .)
    INT             reduce using rule 35 (exp -> exp NE exp .)
    FLOAT           reduce using rule 35 (exp -> exp NE exp .)
    NOT             reduce using rule 35 (exp -> exp NE exp .)
    TRUE            reduce using rule 35 (exp -> exp NE exp .)
    FALSE           reduce using rule 35 (exp -> exp NE exp .)
    STRING          reduce using rule 35 (exp -> exp NE exp .)
    LPAREN          reduce using rule 35 (exp -> exp NE exp .)
    MAKE            reduce using rule 35 (exp -> exp NE exp .)
    IF              reduce using rule 35 (exp -> exp NE exp .)
    FOR             reduce using rule 35 (exp -> exp NE exp .)
    PRINT           reduce using rule 35 (exp -> exp NE exp .)
    RETURN          reduce using rule 35 (exp -> exp NE exp .)
    $end            reduce using rule 35 (exp -> exp NE exp .)
    RPAREN          reduce using rule 35 (exp -> exp NE exp .)
    THEN            reduce using rule 35 (exp -> exp NE exp .)
    COMMA           reduce using rule 35 (exp -> exp NE exp .)
    TO              reduce using rule 35 (exp -> exp NE exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    GT              shift and go to state 39
    LT              shift and go to state 40
    GTE             shift and go to state 41
    LTE             shift and go to state 42

  ! PLUS            [ reduce using rule 35 (exp -> exp NE exp .) ]
  ! MINUS           [ reduce using rule 35 (exp -> exp NE exp .) ]
  ! MULTIPLY        [ reduce using rule 35 (exp -> exp NE exp .) ]
  ! DIVIDE          [ reduce using rule 35 (exp -> exp NE exp .) ]
  ! GT              [ reduce using rule 35 (exp -> exp NE exp .) ]
  ! LT              [ reduce using rule 35 (exp -> exp NE exp .) ]
  ! GTE             [ reduce using rule 35 (exp -> exp NE exp .) ]
  ! LTE             [ reduce using rule 35 (exp -> exp NE exp .) ]
  ! POWER           [ shift and go to state 35 ]
  ! MODULUS         [ shift and go to state 36 ]
  ! AND             [ shift and go to state 37 ]
  ! OR              [ shift and go to state 38 ]
  ! EE              [ shift and go to state 43 ]
  ! NE              [ shift and go to state 44 ]


state 78

    (17) exp -> NAME LPAREN optargs . RPAREN

    RPAREN          shift and go to state 87


state 79

    (18) optargs -> args .

    RPAREN          reduce using rule 18 (optargs -> args .)


state 80

    (20) args -> exp . COMMA args
    (21) args -> exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

    COMMA           shift and go to state 88
    RPAREN          reduce using rule 21 (args -> exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    POWER           shift and go to state 35
    MODULUS         shift and go to state 36
    AND             shift and go to state 37
    OR              shift and go to state 38
    GT              shift and go to state 39
    LT              shift and go to state 40
    GTE             shift and go to state 41
    LTE             shift and go to state 42
    EE              shift and go to state 43
    NE              shift and go to state 44


state 81

    (52) assignment -> NAME EQUAL exp .
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOL         reduce using rule 52 (assignment -> NAME EQUAL exp .)
    error           reduce using rule 52 (assignment -> NAME EQUAL exp .)
    NAME            reduce using rule 52 (assignment -> NAME EQUAL exp .)
    INT             reduce using rule 52 (assignment -> NAME EQUAL exp .)
    FLOAT           reduce using rule 52 (assignment -> NAME EQUAL exp .)
    DEC             reduce using rule 52 (assignment -> NAME EQUAL exp .)
    INC             reduce using rule 52 (assignment -> NAME EQUAL exp .)
    NOT             reduce using rule 52 (assignment -> NAME EQUAL exp .)
    TRUE            reduce using rule 52 (assignment -> NAME EQUAL exp .)
    FALSE           reduce using rule 52 (assignment -> NAME EQUAL exp .)
    STRING          reduce using rule 52 (assignment -> NAME EQUAL exp .)
    LPAREN          reduce using rule 52 (assignment -> NAME EQUAL exp .)
    MAKE            reduce using rule 52 (assignment -> NAME EQUAL exp .)
    IF              reduce using rule 52 (assignment -> NAME EQUAL exp .)
    FOR             reduce using rule 52 (assignment -> NAME EQUAL exp .)
    PRINT           reduce using rule 52 (assignment -> NAME EQUAL exp .)
    RETURN          reduce using rule 52 (assignment -> NAME EQUAL exp .)
    $end            reduce using rule 52 (assignment -> NAME EQUAL exp .)
    TO              reduce using rule 52 (assignment -> NAME EQUAL exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    POWER           shift and go to state 35
    MODULUS         shift and go to state 36
    AND             shift and go to state 37
    OR              shift and go to state 38
    GT              shift and go to state 39
    LT              shift and go to state 40
    GTE             shift and go to state 41
    LTE             shift and go to state 42
    EE              shift and go to state 43
    NE              shift and go to state 44

  ! MINUS           [ reduce using rule 52 (assignment -> NAME EQUAL exp .) ]


state 82

    (49) exp -> LPAREN exp RPAREN .

    PLUS            reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    MULTIPLY        reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    POWER           reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    MODULUS         reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    AND             reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    OR              reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    GT              reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    LT              reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    GTE             reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    LTE             reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    EE              reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    NE              reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    DEC             reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    INC             reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    SEMICOL         reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    error           reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    NAME            reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    INT             reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    FLOAT           reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    NOT             reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    TRUE            reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    FALSE           reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    STRING          reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    LPAREN          reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    MAKE            reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    IF              reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    FOR             reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    PRINT           reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    RETURN          reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    $end            reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    THEN            reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 49 (exp -> LPAREN exp RPAREN .)
    TO              reduce using rule 49 (exp -> LPAREN exp RPAREN .)


state 83

    (53) if -> IF exp THEN . stmtblock
    (14) stmtblock -> . LBRACE stmtS RBRACE

    LBRACE          shift and go to state 90

    stmtblock                      shift and go to state 89

state 84

    (56) for -> FOR assignment TO . INT UNTIL

    INT             shift and go to state 91


state 85

    (57) for -> FOR makevar TO . INT UNTIL

    INT             shift and go to state 92


state 86

    (58) print -> PRINT LPAREN exp . RPAREN
    (22) exp -> exp . PLUS exp
    (23) exp -> exp . MINUS exp
    (24) exp -> exp . MULTIPLY exp
    (25) exp -> exp . DIVIDE exp
    (26) exp -> exp . POWER exp
    (27) exp -> exp . MODULUS exp
    (28) exp -> exp . AND exp
    (29) exp -> exp . OR exp
    (30) exp -> exp . GT exp
    (31) exp -> exp . LT exp
    (32) exp -> exp . GTE exp
    (33) exp -> exp . LTE exp
    (34) exp -> exp . EE exp
    (35) exp -> exp . NE exp

    RPAREN          shift and go to state 93
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    POWER           shift and go to state 35
    MODULUS         shift and go to state 36
    AND             shift and go to state 37
    OR              shift and go to state 38
    GT              shift and go to state 39
    LT              shift and go to state 40
    GTE             shift and go to state 41
    LTE             shift and go to state 42
    EE              shift and go to state 43
    NE              shift and go to state 44


state 87

    (17) exp -> NAME LPAREN optargs RPAREN .

    PLUS            reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    MINUS           reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    MULTIPLY        reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    DIVIDE          reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    POWER           reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    MODULUS         reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    AND             reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    OR              reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    GT              reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    LT              reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    GTE             reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    LTE             reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    EE              reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    NE              reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    DEC             reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    INC             reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    SEMICOL         reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    error           reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    NAME            reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    INT             reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    FLOAT           reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    NOT             reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    TRUE            reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    FALSE           reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    STRING          reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    LPAREN          reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    MAKE            reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    IF              reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    FOR             reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    PRINT           reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    RETURN          reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    $end            reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    RPAREN          reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    THEN            reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    COMMA           reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)
    TO              reduce using rule 17 (exp -> NAME LPAREN optargs RPAREN .)


state 88

    (20) args -> exp COMMA . args
    (20) args -> . exp COMMA args
    (21) args -> . exp
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN

    NAME            shift and go to state 50
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13

    exp                            shift and go to state 80
    args                           shift and go to state 94

state 89

    (53) if -> IF exp THEN stmtblock .

    SEMICOL         reduce using rule 53 (if -> IF exp THEN stmtblock .)
    error           reduce using rule 53 (if -> IF exp THEN stmtblock .)
    NAME            reduce using rule 53 (if -> IF exp THEN stmtblock .)
    MINUS           reduce using rule 53 (if -> IF exp THEN stmtblock .)
    INT             reduce using rule 53 (if -> IF exp THEN stmtblock .)
    FLOAT           reduce using rule 53 (if -> IF exp THEN stmtblock .)
    DEC             reduce using rule 53 (if -> IF exp THEN stmtblock .)
    INC             reduce using rule 53 (if -> IF exp THEN stmtblock .)
    NOT             reduce using rule 53 (if -> IF exp THEN stmtblock .)
    TRUE            reduce using rule 53 (if -> IF exp THEN stmtblock .)
    FALSE           reduce using rule 53 (if -> IF exp THEN stmtblock .)
    STRING          reduce using rule 53 (if -> IF exp THEN stmtblock .)
    LPAREN          reduce using rule 53 (if -> IF exp THEN stmtblock .)
    MAKE            reduce using rule 53 (if -> IF exp THEN stmtblock .)
    IF              reduce using rule 53 (if -> IF exp THEN stmtblock .)
    FOR             reduce using rule 53 (if -> IF exp THEN stmtblock .)
    PRINT           reduce using rule 53 (if -> IF exp THEN stmtblock .)
    RETURN          reduce using rule 53 (if -> IF exp THEN stmtblock .)
    $end            reduce using rule 53 (if -> IF exp THEN stmtblock .)


state 90

    (14) stmtblock -> LBRACE . stmtS RBRACE
    (15) stmtS -> . stmt SEMICOL stmtS
    (16) stmtS -> .
    (5) stmt -> . exp
    (6) stmt -> . makevar
    (7) stmt -> . assignment
    (8) stmt -> . if
    (9) stmt -> . for
    (10) stmt -> . print
    (11) stmt -> . incdec
    (12) stmt -> . return
    (13) stmt -> . error
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN
    (50) makevar -> . MAKE NAME
    (51) makevar -> . MAKE assignment
    (52) assignment -> . NAME EQUAL exp
    (53) if -> . IF exp THEN stmtblock
    (56) for -> . FOR assignment TO INT UNTIL
    (57) for -> . FOR makevar TO INT UNTIL
    (58) print -> . PRINT LPAREN exp RPAREN
    (43) incdec -> . exp DEC
    (44) incdec -> . exp INC
    (59) return -> . RETURN exp

    RBRACE          reduce using rule 16 (stmtS -> .)
    error           shift and go to state 97
    NAME            shift and go to state 12
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13
    MAKE            shift and go to state 23
    IF              shift and go to state 24
    FOR             shift and go to state 25
    PRINT           shift and go to state 26
    RETURN          shift and go to state 27

    stmtS                          shift and go to state 95
    stmt                           shift and go to state 96
    exp                            shift and go to state 4
    makevar                        shift and go to state 5
    assignment                     shift and go to state 6
    if                             shift and go to state 7
    for                            shift and go to state 8
    print                          shift and go to state 9
    incdec                         shift and go to state 10
    return                         shift and go to state 11

state 91

    (56) for -> FOR assignment TO INT . UNTIL

    UNTIL           shift and go to state 98


state 92

    (57) for -> FOR makevar TO INT . UNTIL

    UNTIL           shift and go to state 99


state 93

    (58) print -> PRINT LPAREN exp RPAREN .

    SEMICOL         reduce using rule 58 (print -> PRINT LPAREN exp RPAREN .)
    error           reduce using rule 58 (print -> PRINT LPAREN exp RPAREN .)
    NAME            reduce using rule 58 (print -> PRINT LPAREN exp RPAREN .)
    MINUS           reduce using rule 58 (print -> PRINT LPAREN exp RPAREN .)
    INT             reduce using rule 58 (print -> PRINT LPAREN exp RPAREN .)
    FLOAT           reduce using rule 58 (print -> PRINT LPAREN exp RPAREN .)
    DEC             reduce using rule 58 (print -> PRINT LPAREN exp RPAREN .)
    INC             reduce using rule 58 (print -> PRINT LPAREN exp RPAREN .)
    NOT             reduce using rule 58 (print -> PRINT LPAREN exp RPAREN .)
    TRUE            reduce using rule 58 (print -> PRINT LPAREN exp RPAREN .)
    FALSE           reduce using rule 58 (print -> PRINT LPAREN exp RPAREN .)
    STRING          reduce using rule 58 (print -> PRINT LPAREN exp RPAREN .)
    LPAREN          reduce using rule 58 (print -> PRINT LPAREN exp RPAREN .)
    MAKE            reduce using rule 58 (print -> PRINT LPAREN exp RPAREN .)
    IF              reduce using rule 58 (print -> PRINT LPAREN exp RPAREN .)
    FOR             reduce using rule 58 (print -> PRINT LPAREN exp RPAREN .)
    PRINT           reduce using rule 58 (print -> PRINT LPAREN exp RPAREN .)
    RETURN          reduce using rule 58 (print -> PRINT LPAREN exp RPAREN .)
    $end            reduce using rule 58 (print -> PRINT LPAREN exp RPAREN .)


state 94

    (20) args -> exp COMMA args .

    RPAREN          reduce using rule 20 (args -> exp COMMA args .)


state 95

    (14) stmtblock -> LBRACE stmtS . RBRACE

    RBRACE          shift and go to state 100


state 96

    (15) stmtS -> stmt . SEMICOL stmtS

    SEMICOL         shift and go to state 101


state 97

    (13) stmt -> error .

    SEMICOL         reduce using rule 13 (stmt -> error .)


state 98

    (56) for -> FOR assignment TO INT UNTIL .

    SEMICOL         reduce using rule 56 (for -> FOR assignment TO INT UNTIL .)
    error           reduce using rule 56 (for -> FOR assignment TO INT UNTIL .)
    NAME            reduce using rule 56 (for -> FOR assignment TO INT UNTIL .)
    MINUS           reduce using rule 56 (for -> FOR assignment TO INT UNTIL .)
    INT             reduce using rule 56 (for -> FOR assignment TO INT UNTIL .)
    FLOAT           reduce using rule 56 (for -> FOR assignment TO INT UNTIL .)
    DEC             reduce using rule 56 (for -> FOR assignment TO INT UNTIL .)
    INC             reduce using rule 56 (for -> FOR assignment TO INT UNTIL .)
    NOT             reduce using rule 56 (for -> FOR assignment TO INT UNTIL .)
    TRUE            reduce using rule 56 (for -> FOR assignment TO INT UNTIL .)
    FALSE           reduce using rule 56 (for -> FOR assignment TO INT UNTIL .)
    STRING          reduce using rule 56 (for -> FOR assignment TO INT UNTIL .)
    LPAREN          reduce using rule 56 (for -> FOR assignment TO INT UNTIL .)
    MAKE            reduce using rule 56 (for -> FOR assignment TO INT UNTIL .)
    IF              reduce using rule 56 (for -> FOR assignment TO INT UNTIL .)
    FOR             reduce using rule 56 (for -> FOR assignment TO INT UNTIL .)
    PRINT           reduce using rule 56 (for -> FOR assignment TO INT UNTIL .)
    RETURN          reduce using rule 56 (for -> FOR assignment TO INT UNTIL .)
    $end            reduce using rule 56 (for -> FOR assignment TO INT UNTIL .)


state 99

    (57) for -> FOR makevar TO INT UNTIL .

    SEMICOL         reduce using rule 57 (for -> FOR makevar TO INT UNTIL .)
    error           reduce using rule 57 (for -> FOR makevar TO INT UNTIL .)
    NAME            reduce using rule 57 (for -> FOR makevar TO INT UNTIL .)
    MINUS           reduce using rule 57 (for -> FOR makevar TO INT UNTIL .)
    INT             reduce using rule 57 (for -> FOR makevar TO INT UNTIL .)
    FLOAT           reduce using rule 57 (for -> FOR makevar TO INT UNTIL .)
    DEC             reduce using rule 57 (for -> FOR makevar TO INT UNTIL .)
    INC             reduce using rule 57 (for -> FOR makevar TO INT UNTIL .)
    NOT             reduce using rule 57 (for -> FOR makevar TO INT UNTIL .)
    TRUE            reduce using rule 57 (for -> FOR makevar TO INT UNTIL .)
    FALSE           reduce using rule 57 (for -> FOR makevar TO INT UNTIL .)
    STRING          reduce using rule 57 (for -> FOR makevar TO INT UNTIL .)
    LPAREN          reduce using rule 57 (for -> FOR makevar TO INT UNTIL .)
    MAKE            reduce using rule 57 (for -> FOR makevar TO INT UNTIL .)
    IF              reduce using rule 57 (for -> FOR makevar TO INT UNTIL .)
    FOR             reduce using rule 57 (for -> FOR makevar TO INT UNTIL .)
    PRINT           reduce using rule 57 (for -> FOR makevar TO INT UNTIL .)
    RETURN          reduce using rule 57 (for -> FOR makevar TO INT UNTIL .)
    $end            reduce using rule 57 (for -> FOR makevar TO INT UNTIL .)


state 100

    (14) stmtblock -> LBRACE stmtS RBRACE .

    SEMICOL         reduce using rule 14 (stmtblock -> LBRACE stmtS RBRACE .)
    error           reduce using rule 14 (stmtblock -> LBRACE stmtS RBRACE .)
    NAME            reduce using rule 14 (stmtblock -> LBRACE stmtS RBRACE .)
    MINUS           reduce using rule 14 (stmtblock -> LBRACE stmtS RBRACE .)
    INT             reduce using rule 14 (stmtblock -> LBRACE stmtS RBRACE .)
    FLOAT           reduce using rule 14 (stmtblock -> LBRACE stmtS RBRACE .)
    DEC             reduce using rule 14 (stmtblock -> LBRACE stmtS RBRACE .)
    INC             reduce using rule 14 (stmtblock -> LBRACE stmtS RBRACE .)
    NOT             reduce using rule 14 (stmtblock -> LBRACE stmtS RBRACE .)
    TRUE            reduce using rule 14 (stmtblock -> LBRACE stmtS RBRACE .)
    FALSE           reduce using rule 14 (stmtblock -> LBRACE stmtS RBRACE .)
    STRING          reduce using rule 14 (stmtblock -> LBRACE stmtS RBRACE .)
    LPAREN          reduce using rule 14 (stmtblock -> LBRACE stmtS RBRACE .)
    MAKE            reduce using rule 14 (stmtblock -> LBRACE stmtS RBRACE .)
    IF              reduce using rule 14 (stmtblock -> LBRACE stmtS RBRACE .)
    FOR             reduce using rule 14 (stmtblock -> LBRACE stmtS RBRACE .)
    PRINT           reduce using rule 14 (stmtblock -> LBRACE stmtS RBRACE .)
    RETURN          reduce using rule 14 (stmtblock -> LBRACE stmtS RBRACE .)
    $end            reduce using rule 14 (stmtblock -> LBRACE stmtS RBRACE .)


state 101

    (15) stmtS -> stmt SEMICOL . stmtS
    (15) stmtS -> . stmt SEMICOL stmtS
    (16) stmtS -> .
    (5) stmt -> . exp
    (6) stmt -> . makevar
    (7) stmt -> . assignment
    (8) stmt -> . if
    (9) stmt -> . for
    (10) stmt -> . print
    (11) stmt -> . incdec
    (12) stmt -> . return
    (13) stmt -> . error
    (17) exp -> . NAME LPAREN optargs RPAREN
    (22) exp -> . exp PLUS exp
    (23) exp -> . exp MINUS exp
    (24) exp -> . exp MULTIPLY exp
    (25) exp -> . exp DIVIDE exp
    (26) exp -> . exp POWER exp
    (27) exp -> . exp MODULUS exp
    (28) exp -> . exp AND exp
    (29) exp -> . exp OR exp
    (30) exp -> . exp GT exp
    (31) exp -> . exp LT exp
    (32) exp -> . exp GTE exp
    (33) exp -> . exp LTE exp
    (34) exp -> . exp EE exp
    (35) exp -> . exp NE exp
    (36) exp -> . NAME
    (37) exp -> . MINUS INT
    (38) exp -> . MINUS FLOAT
    (39) exp -> . INT
    (40) exp -> . FLOAT
    (41) exp -> . DEC exp
    (42) exp -> . INC exp
    (45) exp -> . NOT exp
    (46) exp -> . TRUE
    (47) exp -> . FALSE
    (48) exp -> . STRING
    (49) exp -> . LPAREN exp RPAREN
    (50) makevar -> . MAKE NAME
    (51) makevar -> . MAKE assignment
    (52) assignment -> . NAME EQUAL exp
    (53) if -> . IF exp THEN stmtblock
    (56) for -> . FOR assignment TO INT UNTIL
    (57) for -> . FOR makevar TO INT UNTIL
    (58) print -> . PRINT LPAREN exp RPAREN
    (43) incdec -> . exp DEC
    (44) incdec -> . exp INC
    (59) return -> . RETURN exp

    RBRACE          reduce using rule 16 (stmtS -> .)
    error           shift and go to state 97
    NAME            shift and go to state 12
    MINUS           shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    DEC             shift and go to state 17
    INC             shift and go to state 18
    NOT             shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22
    LPAREN          shift and go to state 13
    MAKE            shift and go to state 23
    IF              shift and go to state 24
    FOR             shift and go to state 25
    PRINT           shift and go to state 26
    RETURN          shift and go to state 27

    stmt                           shift and go to state 96
    stmtS                          shift and go to state 102
    exp                            shift and go to state 4
    makevar                        shift and go to state 5
    assignment                     shift and go to state 6
    if                             shift and go to state 7
    for                            shift and go to state 8
    print                          shift and go to state 9
    incdec                         shift and go to state 10
    return                         shift and go to state 11

state 102

    (15) stmtS -> stmt SEMICOL stmtS .

    RBRACE          reduce using rule 15 (stmtS -> stmt SEMICOL stmtS .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SEMICOL in state 3 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 4 resolved as shift
WARNING: shift/reduce conflict for DEC in state 4 resolved as shift
WARNING: shift/reduce conflict for INC in state 4 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 12 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 50 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 63 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 68 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 68 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 68 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 68 resolved as shift
WARNING: shift/reduce conflict for POWER in state 68 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 68 resolved as shift
WARNING: shift/reduce conflict for AND in state 68 resolved as shift
WARNING: shift/reduce conflict for OR in state 68 resolved as shift
WARNING: shift/reduce conflict for GT in state 68 resolved as shift
WARNING: shift/reduce conflict for LT in state 68 resolved as shift
WARNING: shift/reduce conflict for GTE in state 68 resolved as shift
WARNING: shift/reduce conflict for LTE in state 68 resolved as shift
WARNING: shift/reduce conflict for EE in state 68 resolved as shift
WARNING: shift/reduce conflict for NE in state 68 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 69 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 69 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 69 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 69 resolved as shift
WARNING: shift/reduce conflict for POWER in state 69 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 69 resolved as shift
WARNING: shift/reduce conflict for AND in state 69 resolved as shift
WARNING: shift/reduce conflict for OR in state 69 resolved as shift
WARNING: shift/reduce conflict for GT in state 69 resolved as shift
WARNING: shift/reduce conflict for LT in state 69 resolved as shift
WARNING: shift/reduce conflict for GTE in state 69 resolved as shift
WARNING: shift/reduce conflict for LTE in state 69 resolved as shift
WARNING: shift/reduce conflict for EE in state 69 resolved as shift
WARNING: shift/reduce conflict for NE in state 69 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 81 resolved as shift
